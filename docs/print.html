<!DOCTYPE HTML>
<html lang="ru" class="sidebar-visible no-js light">
    
<!-- Mirrored from caos2023.myltsev.ru/lectures/print.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 15 Jan 2024 12:00:11 GMT -->
<head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>HSE CAOS 2023</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="../../cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJaxdda6.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="01-course.html">Как устроен курс</a></li><li class="chapter-item expanded "><a href="02-computers.html"><strong aria-hidden="true">1.</strong> Компьютеры</a></li><li class="chapter-item expanded "><a href="03-integers.html"><strong aria-hidden="true">2.</strong> Целые числа</a></li><li class="chapter-item expanded "><a href="04-assembly.html"><strong aria-hidden="true">3.</strong> Язык ассемблера</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05-jumps.html"><strong aria-hidden="true">3.1.</strong> Переходы</a></li><li class="chapter-item expanded "><a href="06-nand2cpu.html"><strong aria-hidden="true">3.2.</strong> Как сделать CPU из транзисторов</a></li><li class="chapter-item expanded "><a href="07-memory.html"><strong aria-hidden="true">3.3.</strong> Обращение к памяти</a></li><li class="chapter-item expanded "><a href="08-call-ret/08-call-ret.html"><strong aria-hidden="true">3.4.</strong> Подпрограммы</a></li><li class="chapter-item expanded "><a href="09-elf/index.html"><strong aria-hidden="true">3.5.</strong> Компоновка</a></li><li class="chapter-item expanded "><a href="x1-cpu-internals/index.html"><strong aria-hidden="true">3.6.</strong> Внутренности современных процессоров</a></li></ol></li><li class="chapter-item expanded "><a href="10-c/index.html"><strong aria-hidden="true">4.</strong> Язык Си</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="11-c-continued/index.html"><strong aria-hidden="true">4.1.</strong> Динамическая память</a></li><li class="chapter-item expanded "><a href="12-c-bit-twiddling/index.html"><strong aria-hidden="true">4.2.</strong> Bits and pieces</a></li></ol></li><li class="chapter-item expanded "><a href="ipr/git.html"><strong aria-hidden="true">5.</strong> Git</a></li><li class="chapter-item expanded "><a href="13-io/index.html"><strong aria-hidden="true">6.</strong> «Системное программирование»</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="interrupts/Interrupts.html"><strong aria-hidden="true">6.1.</strong> Прерывания</a></li><li class="chapter-item expanded "><a href="15-rings/rings.html"><strong aria-hidden="true">6.2.</strong> Кольца защиты</a></li></ol></li><li class="chapter-item expanded "><a href="16-files/index.html"><strong aria-hidden="true">7.</strong> Файлы</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="17-file-system/index.html"><strong aria-hidden="true">7.1.</strong> Файловая система</a></li></ol></li><li class="chapter-item expanded "><a href="18-floating-point-arithmetic/index.html"><strong aria-hidden="true">8.</strong> Вещественные числа</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="18-x86-floating-point/index.html"><strong aria-hidden="true">8.1.</strong> Поддержка на x86: FPU, MMX, SSE, AVX</a></li></ol></li><li class="chapter-item expanded "><a href="22-sockets/index.html"><strong aria-hidden="true">9.</strong> Сети и сокеты</a></li><li class="chapter-item expanded "><a href="19-process/index.html"><strong aria-hidden="true">10.</strong> Процессы</a></li><li class="chapter-item expanded "><a href="25-shared-mem/index.html"><strong aria-hidden="true">11.</strong> Работа с общей памятью</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="26-parallel-2/index.html"><strong aria-hidden="true">11.1.</strong> RMW</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">HSE CAOS 2023</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="О-чём-курс"><a class="header" href="#О-чём-курс">О чём курс</a></h2>
<p>Мы умеем писать функционирующие программы на ЯВУ:</p>
<ul>
<li>пишем текст программы;</li>
<li>компилятор делает из него исполняемый файл</li>
<li>(и у компилятора есть настройка &quot;оптимизировать&quot; программу);</li>
<li>исполняемый файл можно запустить на исполнение;</li>
<li>программа выполняется именно так, как в ней написано;</li>
<li>на компьютере вместе работают много программ;</li>
<li>они обращаются к устройствам и используют вычислительные ресурсы;</li>
<li>есть даже Интернет, где можно смотреть котиков в Ютюбе.</li>
</ul>
<p>Все шаги, кроме первого, нуждаются в более подробном рассмотрении.</p>
<h2 id="Как-устроен-курс"><a class="header" href="#Как-устроен-курс">Как устроен курс</a></h2>
<p>Курс разделён на две половины: «Архиктектура компьютера» (1–2 модули) и «Операционные системы
и промышленная разработка» (3–4 модули).</p>
<p>Раз в неделю читается одна или две лекции,
после них, как правило, выдаётся ДЗ — 5 задач
начальной стоимостью 100 баллов каждая.
Через 2 недели после лекции (23:59:59 пятницы) стоимость задач
уменьшается до 50 баллов. Такая стоимость
остаётся до конца семестра.</p>
<p>Задачи проверяются автоматическими тестами в системе ejudge.
В общем случае, штраф за неверную
посылку (не прошедшую тесты) — 1 балл (но лучше ориентироваться на Run penalty).</p>
<p>Часть задач будет подвергаться code review: преподаватели и ассистенты
будут требовать что-то исправить в решении. Пока вы не прислали исправление,
баллы за задачу не учитываются.</p>
<p>Время от времени запускается проверка решений на плагиат. Случаи списывания
расследуются, по результатам могут быть обнулены баллы за соответствующий
контест или направлена служебная записка в УО. Попытки сломать тестирующую
систему тоже приводят к неприятным последствиям.</p>
<h2 id="Контрольные-мероприятия"><a class="header" href="#Контрольные-мероприятия">Контрольные мероприятия</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Когда</th><th>Что</th><th>По какому материалу</th></tr></thead><tbody>
<tr><td>В конце 1-го модуля</td><td>контрольная работа</td><td>по материалам 1 модуля</td></tr>
<tr><td>В конце 2-го модуля</td><td>экзамен</td><td>по 1-му и 2-му модулям</td></tr>
<tr><td>В конце 3-го модуля</td><td>контрольная работа</td><td>по материалам 3 модуля</td></tr>
<tr><td>В конце 4-го модуля</td><td>экзамен</td><td>по 3-му и 4-му модулям</td></tr>
</tbody></table>
</div>
<p>Экзамены и контрольные работы представляют собой контесты в ejudge, в которые
кроме задач добавлено ещё несколько тестов на теорию.</p>
<h2 id="Формула-оценки"><a class="header" href="#Формула-оценки">Формула оценки</a></h2>
<p>Общая идея: оценка за курс складывается из накопленной оценки (за ДЗ и КР)
с весом 0.6 и оценки за экзамен с весом 0.4.</p>
<p>Частности:</p>
<ul>
<li>накопленная оценка (дробная, от 0 до 10) складывается из оценки за ДЗ (от 0 до 9) и оценки за семинары (от 0 до 1 на усмотрение преподавателя);</li>
<li>оценка за ДЗ дробная, от 0 до 9 баллов, точная формула вскоре появится на вики.</li>
</ul>
<p>«Автомат» выдаётся, если оценки за ДЗ и семинары не ниже некоторых пороговых значений, которые будут объявлены дополнительно.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Что-же-такое-компьютер"><a class="header" href="#Что-же-такое-компьютер">Что же такое компьютер</a></h1>
<p>Мы будем говорить про классические цифровые (а именно — двоичные) электронные программируемые вычислители.</p>
<h3 id="Про-что-мы-говорить-не-будем"><a class="header" href="#Про-что-мы-говорить-не-будем">Про что мы говорить не будем</a></h3>
<p><img src="computers/slide-rule.jpg" alt="Аналоговое устройство для вычислений — логарифмическая линейка" /></p>
<p>Аналоговое устройство для вычислений — логарифмическая линейка</p>
<p><img src="computers/felix.jpg" alt="Арифмометр «Феликс»" />
Арифмометр «Феликс»</p>
<p>The <strong>Z1</strong> was a motor-driven mechanical <a href="https://en.wikipedia.org/wiki/Computer">computer</a> designed by <a href="https://en.wikipedia.org/wiki/Konrad_Zuse">Konrad Zuse</a> from 1936 to 1937, which he built in his parents' home from 1936 to 1938. It was a binary electrically driven mechanical calculator with limited programmability, reading instructions from punched celluloid film.</p>
<p><img src="computers/640px-German_Museum_of_Technology_Berlin_2017_024.jpg" alt="Цифровой двоичный программируемый механический вычислитель Z1 (модель)" /></p>
<p>Цифровой двоичный программируемый механический вычислитель <a href="https://en.wikipedia.org/wiki/Z1_(computer)">Z1</a> (модель)</p>
<p><strong>ENIAC</strong> (<a href="https://en.wikipedia.org/wiki/Help:IPA/English">/ˈɛniæk/</a>; <strong>Electronic Numerical Integrator and Computer</strong>) was the first <a href="https://en.wikipedia.org/wiki/Computer_programming">programmable</a>, <a href="https://en.wikipedia.org/wiki/Electronics">electronic</a>, general-purpose <a href="https://en.wikipedia.org/wiki/Digital_computer">digital computer</a>, completed in 1945. Although ENIAC was designed and primarily used to calculate <a href="https://en.wikipedia.org/wiki/Artillery">artillery</a> <a href="https://en.wikipedia.org/wiki/External_ballistics">firing tables</a> for the <a href="https://en.wikipedia.org/wiki/United_States_Army">United States Army</a>'s <a href="https://en.wikipedia.org/wiki/Ballistic_Research_Laboratory">Ballistic Research Laboratory</a>, its first program was a study of the feasibility of the <a href="https://en.wikipedia.org/wiki/Thermonuclear_weapon">thermonuclear weapon</a>.</p>
<p><img src="computers/Two_women_operating_ENIAC_(full_resolution).jpg" alt="Бетти Джин Дженнигс и Рут Байлас программируют электронный компьютер ENIAC" /></p>
<p>Бетти Джин Дженнигс и Рут Байлас программируют электронный компьютер ENIAC</p>
<p><img src="computers/kvantovye-vychisleniya-otjig-s-vyklyuchatelyami-i-prochee-vesele-17.png" alt="Квантовый компьютер IBM Q" /></p>
<p>Квантовый компьютер IBM Q</p>
<h3 id="Про-что-мы-говорить-будем-архитектура-фон-Неймана"><a class="header" href="#Про-что-мы-говорить-будем-архитектура-фон-Неймана">Про что мы говорить будем: архитектура фон Неймана</a></h3>
<p><a href="https://skillbox.ru/media/code/printsipy-fon-neymana-i-pervye-kompyutery-na-ikh-osnove/">https://skillbox.ru/media/code/printsipy-fon-neymana-i-pervye-kompyutery-na-ikh-osnove/</a></p>
<p><img src="computers/von-neumann.png" alt="Архитектура фон Неймана" /></p>
<p>Фон-Неймановский компьютер:</p>
<ul>
<li>электронный, цифровой;</li>
<li>адресуемая память — набор одинаковых пронумерованных ячеек;</li>
<li>хранимая программа в виде набора инструкций;</li>
<li>инструкции исполняются по одной, в определённой последовательности; есть IP — instruction pointer, ячейка памяти внутри control unit, где хранится адрес текущей инструкции;</li>
<li>инструкции и данные хранятся в одной и той же памяти, инструкции можно обрабатывать как данные.</li>
</ul>
<p>Von Neumann bottleneck: одна и та же <em>шина памяти</em>
используется для передачи инструкций и данных.</p>
<p>Типичный шаг исполнения программы:</p>
<ul>
<li>fetch — из памяти приносим следующую инструкцию;</li>
<li>decode — определяем, как она будет исполняться;</li>
<li>execute — исполнение:
<ul>
<li>производим вычисления и обновляем операнды;</li>
<li>обновляем instruction pointer.</li>
</ul>
</li>
</ul>
<pre><code>   ┌───────────────┐
   │               │
   │               │             ┌─────────────┐
...│               │             │     IP      │
   ├───────────────┤             │             │
247│ add x, 1      │◄──────┐     │             │
   ├───────────────┤       └─────┤     247     │
248│ jmp 247       │             └─────────────┘
   ├───────────────┤
249│               │
   ├───────────────┤
250│               │
   ├───────────────┤
...│               │
   │               │
   │               │
   │               │
   └───────────────┘
</code></pre>
<p>ISA (instruction set architecture) —
набор инструкций конкретного компьютера, их семантика
и способ кодирования в памяти.
Примеры ISA: x86, ARM, MIPS, RISC-V.</p>
<p>Компьютеры с одинаковой ISA могут быть по-разному
устроены на уровне <em>микроархитектуры</em> — от этого
может зависеть скорость или эффективность исполнения программ.</p>
<p>См. также: гарвардская архитектура (инструкции и данные отдельно): <a href="https://en.wikipedia.org/wiki/Harvard_architecture">https://en.wikipedia.org/wiki/Harvard_architecture</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Целые-числа"><a class="header" href="#Целые-числа">Целые числа</a></h1>
<p>Двоичное представление:</p>
<p>\( 42 = 32 + 8 + 2 = 2^5 + 2^3 + 2^1 = 101010_2 \).</p>
<p>\( 49 = 32 + 16 + 1 = 2^5 + 2^4 + 2^0 = 110001_2 \).</p>
<p>Нумерация битов:</p>
<pre><code class="language-c">     ... 0 0 1 1 0 0 0 1 = 49
     ... 7 6 5 4 3 2 1 0

&lt;- старшие разряды
     младшие разряды -&gt;
</code></pre>
<p>Ячейки памяти разного размера:</p>
<pre><code class="language-c">8 бит:
00000000 = 0
11111111 = 255

16 бит:
0000000000000000 = 0
1111111111111111 = 65535
...
</code></pre>
<p>Шестнадцатеричные цифры:</p>
<pre><code class="language-c">0000 0         1000 8
0001 1         1001 9
0010 2         1010 a
0011 3         1011 b
0100 4         1100 c
0101 5         1101 d
0110 6         1110 e
0111 7         1111 f
</code></pre>
<p>Например, <code>42 = 0b00101010 = 0x2A</code>. Полезно помнить некоторые степени двойки:</p>
<pre><code class="language-c">2**8  = 256   =   0x100
2**10 = 1024  =   0x400
2**12 = 4096  =  0x1000
2**16 = 65536 = 0x10000
</code></pre>
<p>Переполнение 16-битной ячейки памяти:</p>
<pre><code class="language-c">  0xffff  = 65535
+ 0x0001
= 0x0000

(должно было быть 0x10000, но старший бит не поместился)
</code></pre>
<p>Получается арифметика по модулю \( 2^N \), в данном случае — по модулю \( 2^{16} = 65536 \).</p>
<h2 id="Знаковые-числа"><a class="header" href="#Знаковые-числа">Знаковые числа</a></h2>
<p>Two's complement representation (два-дополнительный код) 
на примере 4-разрядных (4-битных) чисел:</p>
<div class="table-wrapper"><table><thead><tr><th>Биты</th><th style="text-align: right">Число</th></tr></thead><tbody>
<tr><td>0000</td><td style="text-align: right">0</td></tr>
<tr><td>0001</td><td style="text-align: right">1</td></tr>
<tr><td>0010</td><td style="text-align: right">2</td></tr>
<tr><td>0011</td><td style="text-align: right">3</td></tr>
<tr><td>0100</td><td style="text-align: right">4</td></tr>
<tr><td>0101</td><td style="text-align: right">5</td></tr>
<tr><td>0110</td><td style="text-align: right">6</td></tr>
<tr><td><strong>0111</strong></td><td style="text-align: right">7</td></tr>
<tr><td><strong>1000</strong></td><td style="text-align: right">-8</td></tr>
<tr><td>1001</td><td style="text-align: right">-7</td></tr>
<tr><td>1010</td><td style="text-align: right">-6</td></tr>
<tr><td>1011</td><td style="text-align: right">-5</td></tr>
<tr><td>1100</td><td style="text-align: right">-4</td></tr>
<tr><td>1101</td><td style="text-align: right">-3</td></tr>
<tr><td>1110</td><td style="text-align: right">-2</td></tr>
<tr><td>1111</td><td style="text-align: right">-1</td></tr>
</tbody></table>
</div>
<p>Старший бит — знаковый.</p>
<p>\(-x = \bar x + 1\) (побитовая инверсия и сложение), например, \(-0001 = \overline{0001} + 1 = 1110 + 1 = 1111\).</p>
<p>«Переполнение» беззнаковых чисел здесь работает вполне логично:</p>
<pre><code class="language-c">  0xffff  = -1
+ 0x0001
= 0x0000
</code></pre>
<p>Могут быть и другие, реже используемые,
представления знаковых чисел,
например sign-magnitude: бит знака, а в остальных битах
модуль числа. (В таком представлении есть отдельно <code>+0</code> и <code>-0</code>.)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Язык-ассемблера"><a class="header" href="#Язык-ассемблера">Язык ассемблера</a></h1>
<h2 id="Наш-подопытный-кролик--x86"><a class="header" href="#Наш-подопытный-кролик--x86">Наш подопытный кролик — x86</a></h2>
<p><img src="ibm-pc.webp" alt="" />
Компьютер IBM PC, выпущенный в 1981 году, оснащался процессором
Intel 8088, а более поздние модели — процессорами
80286, 80386 и 80486.</p>
<h2 id="Машинный-код-и-язык-ассемблера"><a class="header" href="#Машинный-код-и-язык-ассемблера">Машинный код и язык ассемблера</a></h2>
<p>Читать инструкции процессора в виде чисел очень неудобно (а писать тем более):</p>
<pre><code>    2c93:       48 8d 91 00 00 fe ff
    2c9a:       48 39 c2 
    2c9d:       b8 00 00 02 00
    2ca2:       48 0f 46 c1
</code></pre>
<p>Поэтому для инструкций придумывают названия (мнемоники) и правила записи
их операндов, а потом делают
конвертор из такого текстового представления в двоичное (машинный код).
Такой конвертор называется ассемблером, а текстовое представление инструкций — языком ассемблера.</p>
<pre><code class="language-x86asm">    lea    -0x20000(%rcx),%rdx
    cmp    %rax,%rdx
    mov    $0x20000,%eax
    cmovbe %rcx,%rax
</code></pre>
<p>В мире x86 исторически больше всего используются два синтаксиса языка ассемблера: AT&amp;T vs Intel.
Эти же инструкции в синтаксисе Intel выглядят так:</p>
<pre><code class="language-x86asm">    lea rdx, [rcx - 0x20000]
    cmp rdx, rax
    mov eax, 0x20000
    cmovbe rax, rcx
</code></pre>
<p>Можно заметить, что мнемоники инструкций в основном те же, но операнды записываются иначе
и идут в другом порядке.</p>
<p>Мы будем использовать синтаксис AT&amp;T, потому что в среде GNU он используется по умолчанию.</p>
<h2 id="Регистры"><a class="header" href="#Регистры">Регистры</a></h2>
<p>«Переменные» внутри процессора.</p>
<pre><code>  von Neumann             closer to reality
┌────────────────┐       ┌────────────────┐
│  CPU           │       │ CPU            │
│                │       │                │
│ ┌────────────┐ │       │                │
│ │Control unit│ │       │ Registers      │
│ │            │ │       │                │
│ │IP          │ │       │ (including IP) │
│ └────────────┘ │       │                │
│                │       │                │
└────────┬───────┘       └────────┬───────┘
         │                        │
         │                        │
┌────────┴───────┐       ┌────────┴───────┐
│  Memory        │       │ Cache(s)       │
│                │       │                │
│                │       │                │
│                │       └────────┬───────┘
│                │                │
│                │       ┌────────┴───────┐
│                │       │ RAM            │
│                │       │                │
│                │       │                │
└────────────────┘       └────────────────┘
</code></pre>
<p>Instruction pointer (program counter): <code>eip</code>.</p>
<p>Регистры общего назначения (general purpose registers):</p>
<div class="table-wrapper"><table><thead><tr><th>Регистр</th><th>Младшие 16 бит</th><th>Два младших байта</th></tr></thead><tbody>
<tr><td><code>eax</code></td><td><code>ax</code></td><td><code>ah</code>, <code>al</code></td></tr>
<tr><td><code>ebx</code></td><td><code>bx</code></td><td><code>bh</code>, <code>bl</code></td></tr>
<tr><td><code>ecx</code></td><td><code>cx</code></td><td><code>ch</code>, <code>cl</code></td></tr>
<tr><td><code>edx</code></td><td><code>dx</code></td><td><code>dh</code>, <code>dl</code></td></tr>
<tr><td><code>esi</code></td><td><code>si</code></td><td>—</td></tr>
<tr><td><code>edi</code></td><td><code>di</code></td><td>—</td></tr>
<tr><td><code>ebp</code></td><td><code>bp</code></td><td>—</td></tr>
</tbody></table>
</div>
<p>(Есть ещё регистр <code>esp</code>, который мы пока не трогаем.)</p>
<h2 id="Первые-инструкции"><a class="header" href="#Первые-инструкции">Первые инструкции</a></h2>
<p>Инструкция выглядит примерно так: <code>мнемоника операнд, операнд</code>.</p>
<p>Операнд-регистр записывается после знака процента: <code>%eax</code>.</p>
<p>Наша первая мнемоника: <code>mov</code>.</p>
<pre><code class="language-x86asm">mov SRC, DST   // копировать SRC в DST

movl %eax, %ebx // скопировать биты eax в ebx
                // старое значение ebx теряется
movw %ax, %bx
movb %ah, %bl
</code></pre>
<p>Суффиксы размера операндов:</p>
<ul>
<li><code>b</code> (byte) — 8 бит</li>
<li><code>w</code> (word) — 16 бит</li>
<li><code>l</code> (long) — 32 бита</li>
<li><code>q</code> (quad) — 64 бита (не используем)</li>
</ul>
<p><a href="https://www.felixcloutier.com/x86/mov">Справочник (в синтаксисе Intel)</a></p>
<p><a href="https://www.felixcloutier.com/x86/index.html">Список инструкций</a></p>
<p>Непосредственно заданный операнд:</p>
<pre><code class="language-x86asm">movl $42, %ecx   // положить в %ecx битовое представление числа 42

movl $0x80, %edx // шестнадцатеричная запись операнда
movl $-1, %eax   // установить все биты eax в 1
</code></pre>
<h2 id="Библиотека-simpleio"><a class="header" href="#Библиотека-simpleio">Библиотека simpleio</a></h2>
<pre><code>call writei32   // напечатать на экране значение eax
                // как знаковое десятичное число
call readi32    // ввести с клавиатуры число и сохранить в eax
call readi64    // ввести с клавиатуры число и сохранить в edx:eax
call writei64   // вывести edx:eax
call finish     // завершить исполнение программы
</code></pre>
<p>Наша первая программа на языке ассемблера x86, вычисляющая сумму двух чисел:</p>
<pre><code class="language-x86asm">    .global main
main:
    call readi32     // считали первое число
    movl %eax, %ecx  // сохранили его в ecx
    call readi32     // считали второе число в eax
    addl %ecx, %eax  // сложили первое и второе
    call writei32    // вывели результат
    call finish      // завершили программу
</code></pre>
<p>Сохраним её в файл <code>sum.S</code> (да, заглавная S), оттранслируем и запустим:</p>
<pre><code class="language-sh">$ gcc -m32 -g sum.S simpleio_i686.S -o sum
$ ./sum
</code></pre>
<h2 id="Некоторые-арифметические-инструкции"><a class="header" href="#Некоторые-арифметические-инструкции">Некоторые арифметические инструкции</a></h2>
<pre><code class="language-x86asm">add SRC, DST  // DST += SRC
sub SRC, DST  // DST -= SRC
inc DST       // DST++
dec DST       // DST--
neg DST       // DST = -DST
not DST       // DST = ~DST
and SRC, DST  // DST &amp;= SRC
or  SRC, DST  // DST |= SRC
xor SRC, DST  // DST ^= SRC
</code></pre>
<h2 id="Инструкции-сдвига"><a class="header" href="#Инструкции-сдвига">Инструкции сдвига</a></h2>
<p>Логический сдвиг: двигаем биты внутри регистра,
дополняя его нулями и теряя то, что «выпало».</p>
<pre><code class="language-x86asm">movw $0x1234, %ax
shrw $4, %ax        // ax == 0x0123
shlw $4, %ax        // ax == 0x1230
addw $7, %ax        // ax == 0x1237
rorw $4, %ax        // ax == 0x7123
</code></pre>
<p>Арифметический сдвиг вправо: двигаем биты, дополняя
слева знаковым битом</p>
<pre><code class="language-x86asm">movw 0xfff0, %ax    // ax == -16
sarw $4, %ax        // ax == 0xffff == -1
salw $5, %ax        // ax == 0xfff0 == -16
</code></pre>
<p>См. также <a href="https://www.felixcloutier.com/x86/sal:sar:shl:shr">справочник</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Директивы-ассемблера"><a class="header" href="#Директивы-ассемблера">Директивы ассемблера</a></h2>
<pre><code class="language-x86asm">    .global main            // экспортировать символ main
main:
    movl $42, %eax
    .intel_syntax noprefix
    mov eax, 42             // код в синтаксисе Intel
    .att_syntax noprefix
    movl $42, eax           // noprefix — без символа %
                            // перед операндами-регистрами

    .att_syntax prefix
    .set answer, 4 * 10
    movl $answer + 2, %eax

    nop
    .byte 0x90
    .skip 5, 0x90

    call finish

    .word 1, 2, 3  // или .short 1, 2, 3
    .int 4, 5, 6
    .quad 7, 8, 9
</code></pre>
<h2 id="Переходы-и-метки"><a class="header" href="#Переходы-и-метки">Переходы и метки</a></h2>
<pre><code class="language-x86asm">    .global main
main:
    xor %eax, %eax
    xor %ebx, %ebx
loop:
    inc %eax
    inc %ebx
    jmp loop
</code></pre>
<h2 id="Флаги"><a class="header" href="#Флаги">Флаги</a></h2>
<p>Большинство арифметических инструкций в результате вычисления результата инструкции устанавливают арифметические флаги слова состояния процесса.</p>
<p>Флаг <em>ZF</em> (zero) устанавливается, если в результате операции был получен нуль.</p>
<p>Флаг <em>SF</em> (sign) устанавливается, если в результате операции было получено отрицательное число.</p>
<p>Флаг <em>CF</em> (carry) устанавливается, если в результате выполнения операции произошел перенос из старшего бита результата. Например, для сложения CF устанавливается если результат сложения двух беззнаковых чисел не может быть представлен 32-битным беззнаковым числом.</p>
<p>Флаг <em>OF</em> (overflow) устанавливается, если в результате выполняния операции произошло переполнение знакового результата. Например, при сложении OF устанавливается, если результат сложения двух знаковых чисел не может быть представлен 32-битным знаковым числом.</p>
<p>Обратите внимание, что и сложение addl, и вычитание subl устанавливают одновременно и флаг CF, и флаг OF. Сложение и вычитание знаковых и беззнаковых чисел выполняется совершенно одинаково, и поэтому используется одна инструкция и для знаковой, и для беззнаковой операции.</p>
<pre><code class="language-x86asm">    stc  // установить CF
    clc  // сбросить CF
    setc %al  // установить %al в 0 или 1 в зависимости от флага
    // seto, setz, ...
</code></pre>
<h2 id="Условные-переходы"><a class="header" href="#Условные-переходы">Условные переходы</a></h2>
<p><a href="https://www.felixcloutier.com/x86/jcc">см. справочник</a></p>
<pre><code>    jz      label   /* переход, если равно (нуль), ZF == 1 */
    jnz     label   /* переход, если не равно (не нуль), ZF == 0 */
    jc      label   /* переход, если CF == 1 */
    jnc     label   /* переход, если CF == 0 */
    jo      label   /* переход, если OF == 1 */
    jno     label   /* переход, если OF == 0 */
    jg      label   /* переход, если больше для знаковых чисел */
    jge     label   /* переход, если &gt;= для знаковых чисел */
    jl      label   /* переход, если &lt; для знаковых чисел */
    jle     label   /* переход, если &lt;= для знаковых чисел */
    ja      label   /* переход, если &gt; для беззнаковых чисел */
    jae     label   /* переход, если &gt;= (беззнаковый) */
    jb      label   /* переход, если &lt; (беззнаковый) */
    jbe     label   /* переход, если &lt;= (беззнаковый) */
</code></pre>
<p>Посчитаем до 20:</p>
<pre><code class="language-x86asm">main:
    xor %eax, %eax
loop:
    add $3, %eax
    call writei32
    mov %eax, %ecx
    subl $20, %ecx
    jl loop
    // тут чего-то не хватает

    .globl main
</code></pre>
<pre><code class="language-x86asm">    cmp src, dst  // недеструктивная версия sub
    test src, dst // недеструктивная версия and
</code></pre>
<h2 id="Длинная-арифметика"><a class="header" href="#Длинная-арифметика">Длинная арифметика</a></h2>
<p>Сложим 64-разрядные числа в edx:eax и edi:esi:</p>
<pre><code class="language-x86asm">    add %esi, %eax  // сложили младшие половины
    jnc 1f
    inc %edx        // если был перенос, добавляем 1
1:
    add %edi, %edx  // сложили старшие половины
</code></pre>
<p>Чтобы не выписывать такую последовательность инструкций, есть инструкция <code>adc</code> (add with carry),
которая прибавляет ко второму операнду не только первый операнд, но и значение
флага CF:</p>
<pre><code class="language-x86asm">    add %esi, %eax
    adc %edi, %edx
</code></pre>
<p>Аналог для вычитания — <code>sbb</code> (subtract with borrow).</p>
<h2 id="Условные-инструкции"><a class="header" href="#Условные-инструкции">Условные инструкции</a></h2>
<p><a href="https://www.felixcloutier.com/x86/cmovcc">см. справочник</a></p>
<p>Инструкция <code>cmovz</code> (conditional move if ZF) работает как <code>mov</code>,
если ZF выставлен, или как <code>nop</code>, если сброшен. Аналогично
с другими условиями.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nand2cpu"><a class="header" href="#nand2cpu">nand2cpu</a></h1>
<p>Архитектура фон Неймана:</p>
<p><img src="nand2cpu/Untitled.png" alt="Untitled" /></p>
<p>Наша задача: сделать процессор (CPU) — цифровое электронное устройство, способное последовательно выполнять инструкции, хранящиеся в памяти (в том числе: доставать из памяти сами инструкции и данные, обрабатывать данные и записывать их обратно в память, а также взаимодействовать с «внешними устройствами»).</p>
<p>Под «обработкой данных» мы обычно понимаем вычисление каких-нибудь функций (в
математическом смысле): например, у нас есть два числа \(x\) и \(y\), а мы
хотим вычислить их сумму \(x+y\). Компьютер у нас двоичный, так что целые числа мы
представляем в двоичной форме — в виде последовательности нулей и единиц:
\( 14 = 1110_2 \),
а вычисления можно представить в виде логических операций.</p>
<p>План действий:</p>
<ol>
<li>
<p>научиться представлять любые функции в виде <em>логических схем;</em></p>
</li>
<li>
<p>научиться последовательно производить вычисления согласно программе (последовательности инструкций);</p>
</li>
<li>
<p>воплотить всё это в виде электронного устройства.</p>
</li>
</ol>
<h3 id="Логические-схемы"><a class="header" href="#Логические-схемы">Логические схемы</a></h3>
<p>Будем собирать схемы из ограниченного количества <em>логических элементов</em>, или <em>логических вентилей</em> (logic gates) — можно выбрать, например, такой <em>базис:</em></p>
<p><img src="nand2cpu/Screenshot_2022-07-16_at_15.29.46.png" alt="Screenshot 2022-07-16 at 15.29.46.png" /></p>
<p>Сделаем <em>двухразрядный сумматор</em> — функцию, которая принимает два одноразрядных числа и возвращает двухразрядное число — их сумму. Напишем сначала таблицу истинности:</p>
<div class="table-wrapper"><table><thead><tr><th>x</th><th>y</th><th>x+y</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>00</td></tr>
<tr><td>0</td><td>1</td><td>01</td></tr>
<tr><td>1</td><td>0</td><td>01</td></tr>
<tr><td>1</td><td>1</td><td>10</td></tr>
</tbody></table>
</div>
<p>Первый (старший) бит — это <code>AND(x, y)</code>, а второй (младший) — это <code>XOR(x, y)</code>. Так и нарисуем:</p>
<p><img src="nand2cpu/Screenshot_2022-07-16_at_15.51.39.png" alt="Screenshot 2022-07-16 at 15.51.39.png" /></p>
<p>Теперь усилим эффект и будем складывать два двухразрядных числа:</p>
<p><img src="nand2cpu/Screenshot_2022-07-16_at_16.07.16.png" alt="Screenshot 2022-07-16 at 16.07.16.png" /></p>
<p>И так далее. В общем, потратив больше или меньше базисных элементов, можно реализовать любую булеву функцию. Можно, например, сделать арифметико-логическое устройство (АЛУ), которое принимает на вход два числа и номер операции (1 — сложение, 2 —вычитание, 3 — умножение…) и выдаёт на выходе результат.</p>
<p>Конечно, любая физическая реализация такой комбинационной логики будет
срабатывать не мгновенно, а с некоторой задержкой. Можно представить себе, как
входной сигнал «протекает» через логические вентили: например, если у каждого
вентиля задержка \(d\), то в предыдущей схеме <code>s0</code> будет вычислено с задержкой
\(d\), а <code>s1</code> с задержкой \(2d\).</p>
<h3 id="Синхронизация"><a class="header" href="#Синхронизация">Синхронизация</a></h3>
<p>Очень неудобно, когда разряды числа оказываются вычислены в разные моменты времени. Хотелось бы научиться в некоторых точках схемы остановиться и подождать, пока какие-то значения не стабилизируются (например, дождать вычисления всех разрядов числа).</p>
<p>Чтобы подождать, нам потребуется некоторое время «помнить» значения в нужных точках схемы. Чтобы добиться такого эффекта, мы выйдем за пределы комбинационной логики (в которой сигнал течёт только «вперёд») и добавим в схему цикл.</p>
<p><img src="nand2cpu/Screenshot_2022-07-16_at_18.20.17.png" alt="Триггер (SR latch)" /></p>
<p>Триггер (SR latch)</p>
<p>Буквы S и R означают Set и Reset. Если подать на входы S=1, R=0, то триггер «запоминает» значение 1; если S=0, R=1, то значение 0; пока S=R=0, триггер находится в самоподдерживающемся состоянии — выход равен «запомненному» значению.</p>
<p>Теперь, чтобы «запереть» триггер, добавим перед ним штуковину, которая может обратить оба входа в ноль:</p>
<p><img src="nand2cpu/Screenshot_2022-07-16_at_18.34.20.png" alt="Синхронный триггер (gated SR latch)" /></p>
<p>Синхронный триггер (gated SR latch)</p>
<p>Пока E=0, триггер не изменит своего состояния Q. Осталось от пары сигналов S/R перейти к одному сигналу data — D:</p>
<p><img src="nand2cpu/Screenshot_2022-07-16_at_19.29.39.png" alt="Синхронный D-триггер (synchronous D-latch)" /></p>
<p>Синхронный D-триггер (synchronous D-latch)</p>
<p>Приделаем такие D-триггеры к нашему сумматору, а на входы E подадим сигнал от <em>тактового генератора</em>, который с некоторой периодичностью на короткое время подаёт туда 1:</p>
<p><img src="nand2cpu/Screenshot_2022-07-16_at_19.19.16.png" alt="Сумматор с защёлкой на выходе" /></p>
<p>Сумматор с защёлкой на выходе</p>
<p>Пока тактовый генератор не подал единицу на входы Е, защёлки хранят своё предыдущее состояние (и обеспечивают стабильный вход для последующих комбинационных цепей). Как только он сработает, значения на защёлках сменятся на вновь вычисленные.</p>
<p>Таким образом, вставляя между защёлками комбинационную логику, мы можем сделать <em>синхронную цепь</em>, в которой в течение <em>такта</em> обновляются значения, которые хранятся на защёлках. <em>Тактовая частота</em> должна быть достаточно низкой, чтобы успела стабилизироваться комбинационная логика, но как можно более высокой, чтобы считать побыстрее :-).</p>
<h3 id="Реализация"><a class="header" href="#Реализация">Реализация</a></h3>
<p><a href="https://habr.com/ru/company/timeweb/blog/653159/">https://habr.com/ru/company/timeweb/blog/653159/</a></p>
<p><img src="nand2cpu/transistors.png" alt="Транзисторы" />
<img src="nand2cpu/transistors2.png" alt="" /></p>
<p><img src="nand2cpu/nand.png" alt="" /></p>
<p><a href="https://en.wikipedia.org/wiki/Wafer_(electronics)"></a></p>
<p><a href="https://www.cpushack.com/MakingWafers.html">Производство микропроцессоров</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Обращения-к-памяти"><a class="header" href="#Обращения-к-памяти">Обращения к памяти</a></h2>
<p>Сохранить значение регистра eax по адресу 0x40100,
а потом загрузить обратно в регистр ebx:</p>
<pre><code class="language-x86asm">    mov %eax, 0x40100
    mov 0x40100, %ebx
</code></pre>
<p>(При этом мы используем 4 байта по адресам
0x40100, 0x40101, 0x40102, 0x40103.)</p>
<p>Положить в память по адресу 0x40100 целое число
0x1543:</p>
<pre><code class="language-x86asm">    movl $0x1543, 0x40100
</code></pre>
<p>Как правило, мы используем в качестве адресов метки:</p>
<pre><code class="language-x86asm">    .global main
main:
    mov x, %eax
    call writei32
    call finish

x:  .int 43
</code></pre>
<p>Не любой адрес в памяти доступен для чтения и тем более записи:</p>
<pre><code class="language-x86asm">    .global main
main:
    incl x
    call finish

x:  .int 43
</code></pre>
<p>При попытке исполнения инструкции <code>incl</code> операционная система
остановит программу с сообщением «Segmentation fault»,
поскольку эти данные нельзя менять.</p>
<h2 id="Секции-data-и-bss"><a class="header" href="#Секции-data-и-bss">Секции .data и .bss</a></h2>
<p>Любые байты, порождаемые ассемблером,
записываются в одну из <em>секций</em> исполняемого
файла. По умолчанию это секция <code>.text</code>, в которой
ожидается машинный код и которая недоступна для записи.</p>
<p>Данные можно положить в секцию <code>.data</code>:</p>
<pre><code class="language-x86asm">    incl x

    .data
x:  .int 43

    .text
    call finish
</code></pre>
<p>Обратите внимание, что ассемблер собирает вместе содержимое каждой
из секций: в примере выше инструкция <code>call</code> окажется в памяти
(и в исполняемом файле)
сразу после <code>incl</code>.</p>
<p>Есть также секция .bss, в которую можно положить только нулевые байты:</p>
<pre><code class="language-x86asm">    .bss
z:  .int 0
    .int 0
    // .int 83  // would be an error
</code></pre>
<p>Typical memory layout:</p>
<pre><code>           ┌──────────────────┐    Executable file
0x0000_0000│//////////////////│   ┌───────────────┐
           │//////////////////│   │ headers       │
           ├──────────────────┤   ├───────────────┤
           │.text   (read and │   │.text          │
           │         execute) │   │               │
      eip─►│                  │   │               │
           │                  │   │               │
           │                  │   │               │
           ├──────────────────┤   ├───────────────┤
           │.data   (read and │   │.data          │
           │         write)   │   │               │
           ├──────────────────┤   └───────────────┘
           │.bss    (read and │
           │         write)   │
           │                  │
           ├──────────────────┤
           │//////////////////│
           │//////////////////│    /// = unmapped region
           │//////////////////│          (inaccessible memory)
           │//////////////////│
           │//////////////////│
           │//////////////////│
      esp─►│stack             │
           │                  │
           │                  │
           │                  │
           │                  │
           ├──────────────────┤
           │//////////////////│
0xffff_ffff│//////////////////│
           └──────────────────┘
</code></pre>
<p>Бывают read-only данные (например, тексты сообщений программы),
для них есть секция <code>.rodata</code>. Эта секция не имеет собственной
директивы, поэтому нужно воспользоваться директивой <code>.section</code>:</p>
<pre><code class="language-x86asm">    .section .rodata
pi_digits:
    .byte 3,1,4,1,5,9,2,6
</code></pre>
<p>(На практике вместо <code>.rodata</code> константные данные часто кладут в <code>.text</code>.)</p>
<h2 id="endianness"><a class="header" href="#endianness">Endianness</a></h2>
<p>x86 — little endian:</p>
<pre><code class="language-x86asm">    // 0x40100:  00 00 00 00  00 00 00 00
    movl $0xabcdef, 0x40100
    // 0x40100:  ef cd ab 00  00 00 00 00
</code></pre>
<p>Младший байт по младшему адресу в памяти.</p>
<h2 id="Расширение"><a class="header" href="#Расширение">Расширение</a></h2>
<pre><code class="language-x86asm">    movzbl %al, %edi  // zero-extend, расширение нулями
    movsbl %al, %edi  // sign-extend, расширение знаковым битом
    cdq  // sign-extend eax to edx:eax
</code></pre>
<p>В синтаксисе Intel —
<a href="https://www.felixcloutier.com/x86/movzx">movzx</a>,
<a href="https://www.felixcloutier.com/x86/movsx">movsx</a>.</p>
<h2 id="Разные-способы-адресации-в-x86"><a class="header" href="#Разные-способы-адресации-в-x86">Разные способы адресации в x86</a></h2>
<pre><code class="language-x86asm">    mov x + 4, %eax   // прямая адресация
    mov $x, %esi      // (положили в esi адрес массива x)
    mov 4(%esi), %eax // косвенная адресация

    mov $17, %edi

    // загружаем в eax 18-й элемент массива
    // (адрес которого %esi + %edi*4)
    mov (%esi, %edi, 4), %eax

    // делаем то же самое
    mov x(, %edi, 4), %eax

    // и ещё раз
    mov x + 17 * 4, %eax

    .bss
x:  .skip 4 * 100

x5: .int x + 4*5      // в x5 лежит адрес шестого элемента массива x
</code></pre>
<p>Общий вид обращения к памяти:</p>
<p><code>OFFSET(BREG, IREG, SCALE)</code></p>
<p>Здесь OFFSET — непосредственно заданное смещение,
BREG — базовый регистр, IREG — индексный регистр,
умножаемый на SCALE (SCALE может быть 1, 2, 4 или 8).</p>
<p>Итоговый адрес (effective address) вычисляется по формуле:</p>
<p><code>BREG + OFFSET + IREG * SCALE</code></p>
<h2 id="Стек"><a class="header" href="#Стек">Стек</a></h2>
<p>Writable область памяти, которая используется
как стек :-). Стек на x86 растёт <em>вниз</em> (от старших адресов к младшим).
На верхушку стека (первый занятый байт) указывает регистр esp.</p>
<p>Скопировать верхушку стека (первые 4 байта) в регистр <code>eax</code>:</p>
<pre><code class="language-x86asm">    mov (%esp), %eax
</code></pre>
<p>Для того, чтобы класть данные на стек и выталкивать их оттуда,
есть специальные инструкции:</p>
<pre><code class="language-x86asm">    push %eax  // то же, что sub $4, %esp; mov %eax, (%esp)
    pop %eax   // то же, что mov (%esp), %eax; add $4, %esp
</code></pre>
<p>Инструкция <code>push</code> одна из немногих, которые могут обратиться
к двум адресам памяти сразу:</p>
<pre><code class="language-x86asm">    .data
x:  .int 1900

    .text
    pushl x  // взять 4 байта из памяти по адресу x
             // и положить их в стек, то есть тоже в память
</code></pre>
<p>Можно пользоваться памятью выше <code>esp</code>, если вы знаете,
что там что-то есть. Например, если вы положили в стек
два 32-битных числа, их можно оттуда читать и там изменять:</p>
<pre><code class="language-x86asm">    pushl $6
    pushl $7

    // теперь стек выглядит так:
    //    07 00 00 00  06 00 00 00 ...
    //    ↑ esp

    mov 4(%esp), %eax  // загрузили в %eax число 6
    incl (%esp)        // теперь на верхушке стека лежит число 8
</code></pre>
<p>Память <em>ниже</em> <code>esp</code> использовать не следует.</p>
<p>Инструкция <code>push %esp</code> кладёт на стек
то значение <code>esp</code>, которое было до её исполнения
(не уменьшенное на 4).</p>
<h2 id="Подпрограммы"><a class="header" href="#Подпрограммы">Подпрограммы</a></h2>
<p>Когда в ДЗ просят сдать «функцию» или «подпрограмму»:</p>
<ol>
<li>исполнение начинается с метки с именем подпрограммы;</li>
<li>метка должна быть <code>.global</code>;</li>
<li>чтобы вернуть управление в проверяющую программу,
используйте инструкцию <code>ret</code>;</li>
<li>если меняете значения регистров, кроме <code>eax</code>, <code>ecx</code> и <code>edx</code>,
сохраняйте их в стек и потом восстанавливайте.</li>
</ol>
<p>Например, если вас просят написать функцию <code>foobar</code>,
и вам нужно менять регистры <code>esi</code> и <code>edi</code>:</p>
<pre><code class="language-x86asm">    .global foobar
foobar:
    push %esi
    push %edi
    ... // делаем что просят, можем портить esi и edi
    pop %edi // восстанавливаем в обратном порядке
    pop %esi
    ret
</code></pre>
<p>(Подробнее в следующей лекции.)</p>
<h2 id="Устройство-ОЗУ"><a class="header" href="#Устройство-ОЗУ">Устройство ОЗУ</a></h2>
<p>Мы уже видели SRAM — память на триггерах.</p>
<p>Основную часть памяти компьютера составляет DRAM:
<img src="dram.png" alt="" /></p>
<p>Процессор и память общаются посредством <em>шины</em> (bus):
<img src="system_bus.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="lea"><a class="header" href="#lea"><code>lea</code></a></h2>
<p>Load effective address — не обращается к памяти,
а загружает в регистр вычисленный адрес:</p>
<pre><code class="language-x86asm">    lea 4(%esi, %edi, 8), %eax  // теперь eax = esi + 8*edi + 4

    lea (%eax, %eax, 8), %eax   // умножили eax на 9 🤡
</code></pre>
<h2 id="Переход-по-адресу-в-регистре"><a class="header" href="#Переход-по-адресу-в-регистре">Переход по адресу в регистре</a></h2>
<pre><code class="language-x86asm">    jmp *%eax
</code></pre>
<p>Например:</p>
<pre><code class="language-x86asm">somelabel:
    ...

    ...
    mov $somelabel, %eax
    jmp *%eax
</code></pre>
<p>Или так:</p>
<pre><code class="language-x86asm">func1:
    ...
func2:
    ...

    .section .rodata
functable:
    .int func1
    .int func2

    .text
    ...
    mov functable + 4, %eax
    jmp *%eax
</code></pre>
<h2 id="Выравнивание"><a class="header" href="#Выравнивание">Выравнивание</a></h2>
<p><img src="08-call-ret/unaligned-read.png" alt="" /></p>
<p>Как правило, <em>лучше</em>, чтобы многобайтовые
обращения к памяти были <em>выровнены</em> (aligned).</p>
<pre><code class="language-x86asm">    // начало секции
    .byte 1
    .int 1    // эти 4 байта лежат по адресу, не кратному 4

    .balign 4 // byte align: здесь добавит 3 байта нулей
    .int 1    // эти 4 байта лежат по адресу, кратному 4

    .balign 2 // не добавит ничего
    .short 1
</code></pre>
<h2 id="Подпрограммы-1"><a class="header" href="#Подпрограммы-1">Подпрограммы</a></h2>
<p>Мы хотим переиспользовать код — вызывать
одну и ту же последовательность инструкций из разных
точек программы.</p>
<pre><code class="language-x86asm">double_eax:
    sal $1, %eax
    jmp ...  // куда?
    

    ...
    jmp double_eax
    // хотим продолжить исполнение здесь

    ...
    jmp double_eax
    // или здесь
</code></pre>
<p>Некоторые архитектуры решают это с помощью
специального регистра для адреса возврата.
Если бы такой был в x86, подпрограммы могли бы
выглядеть так:</p>
<pre><code class="language-x86asm">double_eax:
    sal $1, %eax
    jmp *%return_address
    

    ...
    mov $1f, %return_address
    jmp double_eax
1:

    ...
    mov $1f, %return_address
    jmp double_eax
1:
</code></pre>
<p>Но в x86 принято адрес возврата класть на стек:</p>
<pre><code class="language-x86asm">double_eax:
    sal $1, %eax
    pop %edx        // достаём из стека адрес возврата
    jmp *%edx       // и переходим по нему
    

    ...
    push $1f        // кладём в стек адрес возврата
                    // (адрес следующей инструкции после jmp)
    jmp double_eax  // и переходим на начало подпрограммы
1:

    ...
    push $1f
    jmp double_eax
1:
</code></pre>
<p>Для этих операций (вход в подпрограмму и возвращение из неё)
есть специальные инструкции <code>call</code> и <code>ret</code>:</p>
<pre><code class="language-x86asm">double_eax:
    sal $1, %eax
    ret             // достаём из стека адрес возврата
                    // и переходим по нему
    

    ...
    call double_eax // кладём в стек адрес возврата
                    // (адрес следующей инструкции после call)
                    // и переходим на начало подпрограммы

    ...
    call double_eax
</code></pre>
<p>В подпрограмме важно соблюдать баланс инструкций
<code>push</code> и <code>pop</code>, чтобы не промахнуться мимо адреса возврата.</p>
<h2 id="Соглашения-о-вызовах"><a class="header" href="#Соглашения-о-вызовах">Соглашения о вызовах</a></h2>
<p>Чтобы разные люди (и компиляторы) могли совместно разрабатывать
подпрограммы, им нужно договориться, как передавать
в подпрограмму параметры, как возвращать результат и какие
регистры подпрограмма не будет портить. Такие договорённости
называются <em>соглашениями о вызовах</em> (calling conventions).</p>
<p>Стандартное соглашение на нашей платформе (Linux/x86)
называется <a href="https://en.wikipedia.org/wiki/X86_calling_conventions#cdecl">cdecl</a>:</p>
<ul>
<li>параметры передаются в стеке, причём лежат в памяти
«по порядку» (адрес увеличивается вместе с номером аргумента);</li>
<li>параметры удаляет из стека тот, кто их туда положил
(то есть вызывающая функция);</li>
<li>возвращаемое значение в регистре eax
(а 64-битное — в паре <code>eax:edx</code>);</li>
<li>caller-saved регистры: eax, ecx и edx;</li>
<li>callee-saved регистры: все остальные.</li>
</ul>
<p>Вооружённые этим знанием, мы теперь можем вызывать функции
на Си и быть ими вызваны:</p>
<pre><code class="language-x86asm">    // int foobar(int a, int b)

    pushl b
    pushl a
    call foobar
    add $8, %esp

    // возвращённое значение лежит в %eax
</code></pre>
<pre><code class="language-x86asm">    // возможная реализация функции foobar
    .global foobar
foobar:
    // сейчас стек выглядит так: ra  a  b
    mov 4(%esp), %eax
    add 8(%esp), %eax
    ret
</code></pre>
<h2 id="Локальные-переменные"><a class="header" href="#Локальные-переменные">Локальные переменные</a></h2>
<p>Под них мы выделяем место на стеке:</p>
<pre><code class="language-x86asm">baz:
    sub $8, %esp   // выделили себе 8 байт, в которых неизвестно что
    push $0        // выделили себе 4 байта, в которых 0
    // сейчас стек выглядит так: 0  ?  ?  ra  arg1  arg2...
</code></pre>
<p>Чтобы обращаться к аргументами функции через esp, придётся
помнить, на сколько мы этот esp сместили:</p>
<pre><code class="language-x86asm">    mov 16(%esp), %eax  // достали первый аргумент
</code></pre>
<h2 id="Стековый-кадр"><a class="header" href="#Стековый-кадр">Стековый кадр</a></h2>
<p>Принято при входе в функцию сохранять esp в регистре
ebp (base pointer), а сам ebp соответственно в стеке:</p>
<pre><code class="language-x86asm">quux:
    push %ebp
    mov %esp, %ebp

    /*
    stack layout:  oldebp  ra  arg1  arg2...
                   ↑ ebp
    
    arg1: 8(%ebp)
    arg2: 12(%ebp)...

    local var 1: -4(%ebp)
    local var 2: -8(%ebp)...
    */

    ...

    mov %ebp, %esp
    pop %ebp
    ret
</code></pre>
<p>Стековый кадр (stack frame):</p>
<pre><code>    │   ...         │
    ├───────────────┤
    │  saved ebp    │ ◄─┐
    │               │   │
    │               │   │
    │               │   │
    │  arg2         │   │
    │  arg1         │   │
    │  return addr  │   │
    ├───────────────┤   │
ebp→│  saved ebp    │ ──┘
    │  local1       │
esp→│  local2       │
    │               │
</code></pre>
<h2 id="Текст-не-тот-который-text-а-настоящий"><a class="header" href="#Текст-не-тот-который-text-а-настоящий">Текст (не тот, который <code>.text</code>, а настоящий)</a></h2>
<p>Кодировка <a href="https://en.wikipedia.org/wiki/ASCII#Character_set">ASCII</a>.</p>
<pre><code class="language-x86asm">greeting:
    .byte 'H'  // то же, что .byte 0x48
    .byte 'i'  // то же, что .byte 0x69
    .byte ' '
    .ascii &quot;guy&quot;
    .asciz &quot;s&quot;  // то же, что .ascii &quot;s\0&quot;

    .asciz &quot;Hi guys&quot;  // ещё раз та же последовательность байт
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Многофайловая-сборка"><a class="header" href="#Многофайловая-сборка">Многофайловая сборка</a></h2>
<pre><code>     preprocess        compile        assemble        │
.c ──────────────► .i ──────────► .s ──────────► .o   │
                                                      ├──────►  Executable
                    preprocess        assemble        │ link
               .S ──────────────► .s ──────────► .o   │
                                                      │
</code></pre>
<p>Опции gcc:</p>
<pre><code>-E  stop after preprocessing
-S  stop after compiling to assembly
-c  stop after assembling the object file
</code></pre>
<h2 id="Формат-elf"><a class="header" href="#Формат-elf">Формат ELF</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Википедия</a></p>
<p>Рассмотрим простую программу:</p>
<pre><code class="language-x86asm">// print42.S
    .global main
main:
    mov wrong, %eax
    mov answer, %eax
    call writei32
    call finish

    .data
wrong:
    .int 41
answer:
    .int 42
</code></pre>
<pre><code>$ gcc -m32 -c print42.S -o print42.o
$ gcc -m32 print42.o simpleio_i686.S -o print42
$ nm print42.o
00000004 d answer
         U finish
00000000 T main
         U writei32
00000000 d wrong
$ objdump -d print42
...
080497a5 &lt;main&gt;:
 80497a5:       a1 68 c0 10 08          mov    0x810c068,%eax
 80497aa:       a1 6c c0 10 08          mov    0x810c06c,%eax
 80497af:       e8 5c 00 00 00          call   8049810 &lt;writei32&gt;
 80497b4:       e8 b7 00 00 00          call   8049870 &lt;finish&gt;
...
$ objdump -dr print42.o
00000000 &lt;main&gt;:
   0:   a1 00 00 00 00          mov    0x0,%eax
                        1: R_386_32     .data
   5:   a1 04 00 00 00          mov    0x4,%eax
                        6: R_386_32     .data
   a:   e8 fc ff ff ff          call   b &lt;main+0xb&gt;
                        b: R_386_PC32   writei32
   f:   e8 fc ff ff ff          call   10 &lt;main+0x10&gt;
                        10: R_386_PC32  finish
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Как-работает-cpu"><a class="header" href="#Как-работает-cpu">Как работает CPU</a></h1>
<h2 id="class-risc-pipeline"><a class="header" href="#class-risc-pipeline">Class RISC pipeline</a></h2>
<p><img src="x1-cpu-internals/4-stage-pipeline.png" alt="Классический 4-стадийный конвейер RISC" /></p>
<h2 id="real-life"><a class="header" href="#real-life">Real life</a></h2>
<p><a href="https://agner.org/optimize/#manuals">Документация от Агнера Фога</a></p>
<p><a href="../../agner.org/optimize/microarchitecture.pdf">Про микроархитектуру</a></p>
<h2 id="out-of-order-execution"><a class="header" href="#out-of-order-execution">Out-of-order execution</a></h2>
<h3 id="µops"><a class="header" href="#µops">µops</a></h3>
<pre><code class="language-x86asm">// ISA instructions → µops (names made up)

add %eax, x         → µload  x, %tmp1
                      µadd   %eax, %tmp1
                      µstore %tmp1, x
</code></pre>
<pre><code class="language-x86asm">mov mem1, %eax
imul $5, %eax
add mem2, %eax  // fetch started before imul
mov %eax, mem3
</code></pre>
<h3 id="register-renaming"><a class="header" href="#register-renaming">Register renaming</a></h3>
<blockquote>
<p>Every time an
instruction writes to or modifies a logical register, the microprocessor assigns a new
temporary register to that logical register.</p>
</blockquote>
<pre><code class="language-x86asm">movl mem1, %eax
imull $6, %eax
movl %eax, mem2

movl mem3, %eax  // old value of eax dropped
addl $2, %eax
movl %eax, mem4  // eax retirement
</code></pre>
<h2 id="branch-prediction-предсказание-переходов"><a class="header" href="#branch-prediction-предсказание-переходов">Branch prediction (предсказание переходов)</a></h2>
<p>Predict whether branch is T (taken) or NT (not taken).</p>
<h3 id="loop-vs-conditional"><a class="header" href="#loop-vs-conditional">Loop vs conditional</a></h3>
<p>Stupid approach:</p>
<pre><code class="language-x86asm">loop:
    ...
    jz loop   // T

    ...
    jz else   // NT
    ...
else:
</code></pre>
<p>Predict taken backwards, not taken forwards.</p>
<h3 id="saturating-counter"><a class="header" href="#saturating-counter">Saturating counter</a></h3>
<p>Store state for every branch: T ↔ Weak T ↔ Weak NT ↔ NT</p>
<h3 id="return-prediction"><a class="header" href="#return-prediction">Return prediction</a></h3>
<blockquote>
<p>A Last-In-First-Out buffer, called the return stack buffer,
remembers the return address every time a call instruction is executed, and it uses this for
predicting where the corresponding return will go. This mechanism makes sure that return
instructions are correctly predicted when the same subroutine is called from several
different locations.</p>
</blockquote>
<p>See PDF for better methods.</p>
<h2 id="pipeline-конвейер"><a class="header" href="#pipeline-конвейер">Pipeline (конвейер)</a></h2>
<p>General idea: different stages of execution require different hardware,
so we can parallelize them.</p>
<p><img src="x1-cpu-internals/pipeline.png" alt="Pentium Pro pipeline" /></p>
<p><a href="https://en.wikichip.org/wiki/intel/microarchitectures/sunny_cove#Pipeline">Sunny Cove pipeline</a></p>
<p>Keywords:</p>
<ul>
<li>µop cache</li>
<li>execution unit</li>
<li>micro-op fusion (e.g. memory write: address calculation + data transfer)</li>
<li>macro-op fusion (e.g. cmp + jz)</li>
<li>stack engine (special handling of esp/rsp)</li>
</ul>
<p>µop stages:</p>
<ul>
<li>queued in ROB (reorder buffer)</li>
<li>executing</li>
<li>retirement (register writeback etc.)</li>
</ul>
<p><img src="../../blog.cloudflare.com/branch-predictor/index.html" alt="Testing branch target prediction on different CPUs" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Язык-Си"><a class="header" href="#Язык-Си">Язык Си</a></h1>
<h2 id="История"><a class="header" href="#История">История</a></h2>
<p><img src="10-c/kt-dr-pdp11.jpg" alt="" />
Кен Томпсон и Деннис Ричи у PDP-11</p>
<p><a href="https://en.wikipedia.org/wiki/C_(programming_language)#History">Википедия про историю языка Си</a></p>
<p>Мы используем стандарт С17 (прошлые стандарты: C89, C99, C11; грядёт стандарт C23).</p>
<p><a href="../../www.open-std.org/JTC1/SC22/WG14/www/docs/n1570.pdf">Черновик стандарта</a> (сам стандарт
можно купить у ISO за большие деньги,
там написано то же самое.)</p>
<h2 id="Что-регулирует-стандарт"><a class="header" href="#Что-регулирует-стандарт">Что регулирует стандарт</a></h2>
<ul>
<li>Implementation-defined behavior
<ul>
<li>Пример: представление целых чисел (two's complement, sign-magnitude)</li>
</ul>
</li>
<li>Unspecified behavior 
<ul>
<li>Пример: порядок вычисления аргументов при вызове функции (<code>f(g(), h())</code>)</li>
</ul>
</li>
<li>Undefined behavior (UB)
<ul>
<li>Пример: выход за границы массива</li>
</ul>
</li>
</ul>
<p><a href="https://www.ralfj.de/blog/2021/11/18/ub-good-idea.html">Статья про то, зачем нам нужен UB</a></p>
<pre><code class="language-c">*p = 1;
if (!p) {
    fprintf(stderr, “NULL pointer\n”);
    return;
}
</code></pre>
<h2 id="Целые-типы"><a class="header" href="#Целые-типы">Целые типы</a></h2>
<pre><code class="language-c">char        signed char         unsigned char
short     = signed short        unsigned short
int       = signed int          unsigned int
long      = signed char         unsigned char
long long = signed long long    unsigned long long
</code></pre>
<ul>
<li>CHAR_BIT &gt;= 8</li>
<li>sizeof(char)== 1</li>
<li>sizeof(signed T) == sizeof(unsigned T) == sizeof(T)</li>
<li>short как минимум 16 бит</li>
<li>int как минимум 16 бит</li>
<li>long как минимум 32 бита</li>
<li>long long как минимум 64 бита</li>
</ul>
<p>sizeof для типов:</p>
<pre><code class="language-c">Тип       Atmel AVR  32-bit  Win64  64-bit
char      1          1       1      1
short     2          2       2      2
int       2          4       4      4
long      4          4       4      8
long long -          8       8      8
__int128  -          -       -      16
</code></pre>
<pre><code class="language-c">#include &lt;limits.h&gt;
CHAR_MIN, CHAR_MAX, SCHAR_MIN, SCHAR_MAX,
UCHAR_MIN, ..., INT_MIN, INT_MAX, UINT_MAX,
LONG_MIN, LONG_MAX, ULONG_MAX, LLONG_MIN,
LLONG_MAX, ULLONG_MAX
</code></pre>
<p>Заголовочный файл <code>&lt;stdint.h&gt;</code>:</p>
<ul>
<li>Знаковые типы: <code>int8_t, int16_t, int32_t, int64_t</code></li>
<li>Беззнаковые типы: <code>uint8_t, uint16_t, uint32_t, uint64_t</code></li>
<li>Типы размера, достаточного для хранения
адреса в памяти: <code>intptr_t, uintptr_t</code></li>
<li><code>int8_min_t</code> (минимум 8 бит, но может быть больше, если платформой не поддерживается вариант с 8 битами), <code>int8_fast_t</code>(минимум 8 бит, но больше, если вычисления так производить быстрее)</li>
</ul>
<p>Литералы:</p>
<pre><code class="language-c">0   // int
0U  // unsigned
0UL // unsigned long
0LL // long long
</code></pre>
<h2 id="Знаковая-и-беззнаковая-арифметика"><a class="header" href="#Знаковая-и-беззнаковая-арифметика">Знаковая и беззнаковая арифметика</a></h2>
<p>Unsigned – арифметика по модулю \(2^N\).</p>
<p>Signed – операции с неправильным результатом, как правило, UB.</p>
<pre><code class="language-c">    UINT_MAX + 1;  // OK, always 0
    INT_MAX + 1;   // UB
    int i;
    i &lt; i + 1;     // the compiler may assume this is always true
</code></pre>
<p>Опции gcc:</p>
<ul>
<li><code>-ftrapv</code> – abort() при знаковом целочисленном
переполнении</li>
<li><code>-fwrapv</code> – выполнять знаковые операции по
модулю 2^N, но компилятор не делает
никаких оптимизационных предположений</li>
<li><code>-fsanitize=undefined</code> – частичная проверка на undefined
behavior при работе программы</li>
</ul>
<p>Для обнаружения переполнения в знаковой арифметике можем воспользоваться <a href="https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Builtins.html">GCC built-in overflow detection</a></p>
<h2 id="implicit-conversions"><a class="header" href="#implicit-conversions">Implicit conversions</a></h2>
<p>Integer promotion: числа короче, чем int (то есть char, short) при использовании их в выражениях превратятся в int или unsigned int</p>
<p><a href="https://en.cppreference.com/w/c/language/conversion">cppreference on implicit conversions</a></p>
<h2 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h2>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#define GREETING &quot;Hello, world!\n&quot;
// макрос будет раскрыт в ходе препроцессирования

int main(void) {
    printf(&quot;Hello, world!\n&quot;);
    return 0;
}
</code></pre>
<pre><code class="language-c">int main(){} //объявление функции с неизвестными параметрами
</code></pre>
<pre><code class="language-c">// запуск
gcc hello.c -o hello
./hello
gcc -c hello.c - делает объектный файл
gcc -S hello.c - делает ассемблерный файл
gcc -E hello.c - остановка на стадии препроцессирования
gcc -Wall -Werror // show all warnings, warnings will be treated as errors
</code></pre>
<p>Исполнение начинается с нахождения функции main: если она не нашлась - ошибка компоновки. Main - единственная функция, которая может ничего не возвращать, и это не приведет к UB. В таком случае будет считаться, что main возвращает 0</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#define GREETING &quot;Hello, world\n&quot;

int foobar() {}

int main(void) {
    printf(GREETING);
    int x = foobar(); // UB 
    return 0;
}
</code></pre>
<h3 id="Классы-хранения-переменных"><a class="header" href="#Классы-хранения-переменных">Классы хранения переменных</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#define GREETING &quot;Hello, world\n&quot;

int x; // статический класс хранения

int main(void) {
    int y; // автоматический класс хранения
    printf(GREETING);
    return 0;
}
</code></pre>
<ul>
<li><strong>Автоматический</strong> : переменная объявлена внутри функции (создается при своем объявлении, перестает существовать при завершении функции, то есть живет на стеке). Если не инициализировать, то остается не инициализированной - при использовании будет ub.</li>
<li><strong>Статический:</strong> существует все время, пока существует программа (попадает в секцию data/bss). Автоматически инициализируются 0 (по стандарту), если их не инициализировать.</li>
<li><strong>Регистровый</strong>  - нет адреса в памяти</li>
</ul>
<pre><code class="language-c">register int r;
</code></pre>
<h3 id="extern-static"><a class="header" href="#extern-static">Extern, static</a></h3>
<p><strong>Объявить переменную, определенную в другой единице трансляции</strong></p>
<pre><code class="language-c">extern int x;
</code></pre>
<p><strong>Ключевое слово static</strong></p>
<p>Для статической переменной сообщает компилятору, что в других единицах трансляциях эту переменную нельзя увидеть (то есть переменная перестанет быть экспортируемой (так по умолчанию))</p>
<p>Для автоматической переменной ключевое слово static показывает, что она находится в статической памяти [у нее статический класс хранения]. У нее будет скрытый класс линковки (нельзя увидеть в другой единице трансляции)</p>
<pre><code class="language-c">static int x;
</code></pre>
<h3 id="Запись-заголовочных-файлов-пользовательских-и-системных"><a class="header" href="#Запись-заголовочных-файлов-пользовательских-и-системных">Запись заголовочных файлов: пользовательских и системных</a></h3>
<pre><code class="language-c">//incr.h
int incr(void);
</code></pre>
<pre><code class="language-c">#include &lt;stdio.h&gt; // системный
#include &quot;incr.h&quot;  // пользовательский

#define GREETING &quot;Hello, world\n&quot;

int main(void) {
    printf(printf(&quot;x is %d\n&quot;, incr()));
    return 0;
}
</code></pre>
<h3 id="declarations-and-definitions"><a class="header" href="#declarations-and-definitions">Declarations and definitions</a></h3>
<p>Объявления функций сколько угодно раз, определение только 1.</p>
<p>Заголовочный файл может быть включен в код несколько раз, но может все сломать. Чтобы избежать, используем макрос:</p>
<pre><code class="language-c">//foo.h
#ifndef FOO_H
#define FOO_H

struct foo {
    int x;
};

#endif
</code></pre>
<p>Почти для всех компиляторов вместо этого можно писать  <code>#pragma once</code></p>
<h3 id="Структуры"><a class="header" href="#Структуры">Структуры</a></h3>
<p>Без ключевого слова struct pair не является именем типа. Автоматической инициализации нет, но есть агрегатная. </p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;incr.h&quot;

struct pair { //
    char b;
    int i;
    long long l;
};

int main(void) {
    struct pair p1 = {1, 2, 3}; // инициализация 1
    struct pair p = {.b = 1, .l = 2}; // инициализация 2
    // кого явно не инициализировали - тот 0
    printf(&quot;x is %d\n&quot;, p.i);
}
</code></pre>
<h3 id="Выравнивание-типов"><a class="header" href="#Выравнивание-типов">Выравнивание типов</a></h3>
<p>В си происходит автоматически. Обычно выравнивание равно размеру типа, но не
больше размера машинного слова (int) на данной платформе. Например, на 32-битной
платформе выравнивание <code>long long</code> будет 32 бита.</p>
<p>Чтобы элементы структуры выровнялись, компилятор вставляет между ними
<em>padding</em> - пустые байты. У структуры в целом выравнивание максимальное из всех
ее членов.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;incr.h&quot;

struct pair { // 32 bit platform
    char b;   // 3 empty bytes
    int i;    // 0 empty bytes
    long long l;
};
</code></pre>
<p><strong>Как попросить компилятор не добавлять паддинг</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &quot;incr.h&quot;

struct pair { // 32 bit platform
    char b;   // 3 empty bytes
    int i;    // 0 empty bytes
    long long l;
} __attribute__((packed));
</code></pre>
<h3 id="Массивы"><a class="header" href="#Массивы">Массивы</a></h3>
<pre><code class="language-c">// пустой инициализатор невалиден
int arr[10] = {0} // остальные инициализируются автоматически
// можно инициализировать произвольный элемент массива
int arr[10] = {[5] = 4};

// кол-во элементов = кол-во инициалированных
int arr[] = {1,2,3}
</code></pre>
<p>Выход за границы массива - ub. Узнать размеры массива можно через макрос.</p>
<pre><code class="language-c">#define ARRLEN(a) (sizeof(a) / sizeof((a)[0]))

int main() {
    int arr[10] = {[5] = 4};
    for (int i = 0; i &lt; ARRLEN(arr); ++i) {
        printf(&quot;%d\n&quot;, arr[i]);
    }
}
</code></pre>
<h3 id="Указатели"><a class="header" href="#Указатели">Указатели</a></h3>
<pre><code class="language-c">&amp;p; // взять адрес переменной
int* p = &amp;arr[0]; // указатель
</code></pre>
<ol>
<li>
<p>Разыменование указателя</p>
<pre><code class="language-c">*p;
</code></pre>
</li>
<li>
<p>Арифметика </p>
<p>Прибавить целое число - отступить столько эл-ов в массиве (к адресу указателя прибавляется это число * sizeof(type))</p>
<pre><code class="language-c">int *ptr = &amp;arr[0];
    for (int i = 0; i &lt; ARRLEN(arr); ++i) {
        printf(&quot;%d\n&quot;, *(ptr + i));
    }
</code></pre>
<p>равнозначно</p>
<pre><code class="language-c">int *ptr = &amp;arr[0];
    for (int i = 0; i &lt; ARRLEN(arr); ++i) {
        printf(&quot;%d\n&quot;, ptr[i]);
    }
</code></pre>
</li>
</ol>
<h3 id="Строки"><a class="header" href="#Строки">Строки</a></h3>
<p>0-терминированная строка - массив байт, заканчивающийся на <code>\0</code></p>
<pre><code class="language-c">char[] c = &quot;hello world\n&quot;; // лежит на стеке
c[0]=&quot;H&quot;; //можно менять, но длину строки менять нельзя

//такую строку не получится поменять, она лежит в rodata
char* str = &quot;hello world\n&quot;;
</code></pre>
<p>Длина строки <code>char* str = &quot;hello world\n&quot;</code>:</p>
<pre><code class="language-c">int strlen(char* s){
    int i;
    for (i = 0; s[i] != '\0'; ++i);
    return i;
}

int main(void){
    char* str =  &quot;hello world\n&quot;;
    printf(&quot;%d %s&quot;, strlen(str), str);
}
</code></pre>
<h3 id="printf"><a class="header" href="#printf"><a href="https://man7.org/linux/man-pages/man3/printf.3.html">Printf</a></a></h3>
<pre><code class="language-c">int printf(const char *restrict format, ...);
</code></pre>
<p>Как работает printf: </p>
<ol>
<li>Принимает строчку с форматом</li>
<li>Читает строку, печатает обычные символы, пока не дойдет до символа %</li>
<li>Смотрит спецификатор формата</li>
</ol>
<pre><code class="language-c">&quot;%d&quot; - int
&quot;%s&quot; - char*
&quot;%x&quot; - int в 16ричной системе счисления, &quot;%o&quot; - в 8ричной
</code></pre>
<p>Спецификатор размера</p>
<pre><code class="language-c">h - short
l - long int
</code></pre>
<pre><code class="language-c">short s = 7;
printf(&quot;%d %hd&quot;, strlen(str), s); // integer promotion of s
</code></pre>
<h3 id="scanf"><a class="header" href="#scanf"><a href="https://man7.org/linux/man-pages/man3/scanf.3.html">Scanf</a></a></h3>
<pre><code class="language-c">int scanf(const char *restrict format, ...);
</code></pre>
<ul>
<li>Тут очень важен спецификатор размера числа</li>
<li>Возвращает кол-во считанных элементов; если scanf ничего не считал, возвращает eof</li>
</ul>
<p><strong>Ввод числа</strong></p>
<pre><code class="language-c">int main(void) {
    short shint = 7;
    int result = scanf(&quot;%hd&quot;, &amp;shint);
    if (result == EOF) {
        printf(&quot;empty input\n&quot;);
        return 1;
    }
    if (result != 1) {
        printf(&quot;error\n&quot;);
        return 1;
    }
}
</code></pre>
<p><strong>Ввод строки</strong> - читает до 1 пробела</p>
<pre><code class="language-c">int main(void) {
    char buf[100];

    int result = scanf(&quot;%s&quot;, buf);
    if (result != 1) {
        printf(&quot;error\n&quot;);
        return 1;
    }
    printf(&quot;buf : %s\n&quot;, buf);
}
</code></pre>
<p>Чтобы не начать запись за границами буфера:</p>
<pre><code class="language-c">int main(void) {
    char buf[3] = {0};

    int result = scanf(&quot;%2s&quot;, buf);
    if (result != 1) {
        printf(&quot;error\n&quot;);
        return 1;
    }
    printf(&quot;buf : %s\n&quot;, buf);
}
</code></pre>
<h3 id="Символы-вне-кодровки-ascii---unicode"><a class="header" href="#Символы-вне-кодровки-ascii---unicode">Символы вне кодровки ASCII - Unicode</a></h3>
<p>В ASCII 127 символов, помещаются в 1 байт. Unicode - кодировка, где каждый символ имеет номер code point.</p>
<pre><code class="language-python"># python
ord('f')  # 102
chr(1100) # ь
</code></pre>
<p>В качестве кодировки code points используется теперь в основном utf-8. Она
запихивает все символы в байтовую строку. Символы ascii записываются теми же
кодами. Вне ascii — распилим число на отдельные участки бит, старшими битами
будем кодировать их  последовательность</p>
<pre><code>𝄞 ← U+1D11E MUSICAL SYMBOL G CLEF
0x1d11e = 0b11101_000100_011110

UTF-8: 0b11110_000 0b10_011101 0b10_000100 0b10_011110
</code></pre>
<pre><code class="language-python">In [1]: [bin(b) for b in 'q'.encode('utf-8')]
Out[1]: ['0b01110001']

In [2]: [bin(b) for b in 'я'.encode('utf-8')]
Out[2]: ['0b11010001', '0b10001111']

In [3]: [bin(b) for b in 'ツ'.encode('utf-8')]
Out[3]: ['0b11100011', '0b10000011', '0b10000100']

In [4]: [bin(b) for b in '𝄞'.encode('utf-8')]
Out[4]: ['0b11110000', '0b10011101', '0b10000100', '0b10011110']
</code></pre>
<p>Overlong encoding — использование большего числа байт, чем необходимо:
<code>0b110_00000 0b10_100001</code> → символ <code>chr(0b100001) == '!'</code>.</p>
<p><a href="https://tonsky.me/blog/unicode">Статья про Юникод</a></p>
<h2 id="Структура-программы"><a class="header" href="#Структура-программы">Структура программы</a></h2>
<p>Declarations and definitions</p>
<p>Translation unit</p>
<p>Extern, static</p>
<h2 id="Агрегатные-типы"><a class="header" href="#Агрегатные-типы">Агрегатные типы</a></h2>
<p>Arrays and structures</p>
<p>Aggregate initializers</p>
<p>Array dimensions</p>
<p>Pointer arithmetic</p>
<p>Typedef</p>
<p>Alignment</p>
<h2 id="Другие-темы"><a class="header" href="#Другие-темы">Другие темы</a></h2>
<p>Hosted vs freestanding</p>
<p>Stdio</p>
<p>Argc/argv</p>
<p>Strings</p>
<p>Restrict</p>
<p>Noreturn etc</p>
<p>VLA</p>
<p>Function pointers</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="typedef-and-qualifiers"><a class="header" href="#typedef-and-qualifiers">Typedef and qualifiers</a></h2>
<pre><code class="language-c">typedef int my_int_32_t;
typedef struct foobar {
    ...
} foobar;

const char *s1, *s2;
const int x = 70;
const char * const msg = &quot;hi&quot;;
volatile int counter;
</code></pre>
<h2 id="function-pointers"><a class="header" href="#function-pointers">Function pointers</a></h2>
<pre><code class="language-c">int strcmp(const char *a, const char *b);

// This does not work:
// int *comparator(const char *a, const char *b) = strcmp;

int (*my_comparator)(const char *a, const char *b) = strcmp;

// OK, let's typedef it
typedef int (*comparator_t)(const char *, const char *);

comparator_t comparator = strcmp;

int result1 = (*comparator)(&quot;Roger&quot;, &quot;David&quot;);
int result2 = comparator(&quot;Nick&quot;, &quot;Rick&quot;);

qsort(..., comparator, ...);
</code></pre>
<hr />
<p>Trying to typedef functions directly does not work</p>
<pre><code class="language-c">// int (comparator2)(const char *a, const char *b) = strcmp;

typedef int (comparator_t2)(const char *, const char *); // useless

// comparator_t2 comparator2 = strcmp;
// ^ error: function ‘comparator2’ is initialized like a variable
</code></pre>
<hr />
<p>GCC integer overflow builtins</p>
<pre><code class="language-c">bool __builtin_add_overflow (type1 a, type2 b, type3 *res);
bool __builtin_sub_overflow (type1 a, type2 b, type3 *res);
bool __builtin_mul_overflow (type1 a, type2 b, type3 *res);

char a = 100, b = 200, c;
int d;
__builtin_add_overflow(a, b, &amp;c);
// -&gt; true == overflow

__builtin_add_overflow(a, b, &amp;d);
// -&gt; false == no overflow
</code></pre>
<hr />
<h2 id="printing-fixed-size-types"><a class="header" href="#printing-fixed-size-types">Printing fixed-size types</a></h2>
<p>The problem:</p>
<pre><code class="language-c">uint32_t var;
printf(&quot;%...&quot;, var); // ???
printf(&quot;%d&quot;, var);   // fails on Win16
printf(&quot;%ld&quot;, var);  // fails on 64-bit systems

scanf(&quot;%...&quot;, &amp;var); // even worse
</code></pre>
<hr />
<p>String literal joining</p>
<pre><code class="language-c">char *longstring = &quot;There is no pain, &quot;
                   &quot;you are receding&quot;;
</code></pre>
<hr />
<pre><code class="language-c">#include &lt;inttypes.h&gt;

#define PRId32 &quot;d&quot;
#define PRIu32 &quot;u&quot;
#define PRId64 &quot;ld&quot;
#define PRIu64 &quot;lu&quot;
#define SCNi32 &quot;i&quot;
#define SCNiPTR &quot;li&quot;

uint32_t var;
uintptr_t ptr;
printf(&quot;%&quot; PRId32 &quot;\n&quot;, var);
scanf(&quot;%&quot; SCNi32 &quot;\n&quot;, &amp;var);
scanf(&quot;%&quot; SCNiPTR &quot;\n&quot;, &amp;ptr);
</code></pre>
<hr />
<h2 id="dynamic-memory"><a class="header" href="#dynamic-memory">Dynamic memory</a></h2>
<hr />
<pre><code class="language-c">// man malloc
#include &lt;stdlib.h&gt;

// C11, POSIX
void *malloc(size_t size);
void free(void *ptr);
void *calloc(size_t nmemb, size_t size);
void *realloc(void *ptr, size_t size);

// nonstandard
void *reallocarray(void *ptr, size_t nmemb, size_t size);
</code></pre>
<hr />
<pre><code class="language-c">enum {buf_size = 20};

char *buf = malloc(buf_size);
// type conversion is automatic
// buf == NULL -&gt; allocation error
// otherwise, contents of buf undefined here

strcpy(buf, &quot;arc de Triomphe&quot;);
buf[0] = 'A';
...

free(buf);   // OK
//free(buf); // UB -- double free
buf = NULL;
free(buf);   // OK, free is a no-op here
</code></pre>
<p>-i--</p>
<pre><code class="language-c">int *array = calloc(30, sizeof(*array));
</code></pre>
<p>Similar to, but not the same thing as:</p>
<pre><code class="language-c">int *array = malloc(30 * sizeof(*array));
// check for NULL
memset(array, 0, 30 * sizeof(*array));
</code></pre>
<hr />
<pre><code class="language-c">// same as malloc(100)
void *ptr = realloc(NULL, 100);

// don't do this
// ptr = realloc(ptr, 200);

void *tmp = realloc(ptr, 200);
if (!tmp) {
    perror(&quot;realloc&quot;);
    free(ptr);
    return;
} else {
    ptr = tmp;
}
</code></pre>
<hr />
<p>Dynamic array</p>
<pre><code class="language-c">struct DynArray {
    size_t size;
    size_t capacity;
    int *ptr;
} array = {};

void append(struct DynArray *arr, int value) {
    if (arr-&gt;size + 1 &gt; arr-&gt;capacity) {
        size_t newcap = 2 * (arr-&gt;capacity + 1);
        int *tmp = realloc(arr-&gt;ptr, newcap * sizeof(*tmp));
        if (!tmp) {
            // Handle allocation error
        }
        arr-&gt;ptr = tmp;
        arr-&gt;capacity = newcap;
    }
    arr-&gt;ptr[size++] = value;
}
</code></pre>
<hr />
<p>Better yet:</p>
<pre><code class="language-c">int *tmp = reallocarray(arr-&gt;ptr, newcap, sizeof(*tmp));
</code></pre>
<p>Where <code>reallocarray</code> is not available:</p>
<pre><code class="language-c">size_t size;
if (__builtin_mul_overflow(newcap, sizeof(arr-&gt;ptr[0]), &amp;size)) {
    // Handle overflow
}
int *tmp = realloc(..., size);
</code></pre>
<hr />
<h2 id="example-delete-from-list"><a class="header" href="#example-delete-from-list">Example: delete from list</a></h2>
<p>This won't work:</p>
<pre><code class="language-c">struct List {
    int data;
    struct List *next;
};

void remove(struct List *list, int key) {
    while (list &amp;&amp; list-&gt;data != key) {
        list = list-&gt;next;
    }
    if (!list) {
        return;
    }
    free(list);
    list = list-&gt;next; // use after free
    // no way to update the pointer
}
</code></pre>
<hr />
<pre><code class="language-c">struct List {
    int data;
    struct List *next;
};

void remove(struct List **list, int key) {
    while (*list &amp;&amp; (*list)-&gt;data != key) {
        list = &amp;(*list)-&gt;next;
    }
    if (!*list) {
        return;
    }
    struct List *next = (*list)-&gt;next;
    free(*list);
    *list = next;
}
</code></pre>
<hr />
<h2 id="example-bst-insertion"><a class="header" href="#example-bst-insertion">Example: BST insertion</a></h2>
<pre><code class="language-c">struct TreeNode {
    int data;

    struct TreeNode *left;
    struct TreeNode *right;
};

int main(void) {
    struct TreeNode *root = NULL;
    ...
}
</code></pre>
<hr />
<pre><code class="language-c">struct TreeNode **descend(struct TreeNode **root, int key) {
    while (*root &amp;&amp; (*root)-&gt;data != key) {
        if ((*root)-&gt;data &gt; key) {
            root = &amp;(*root)-&gt;left;
        } else {
            root = &amp;(*root)-&gt;right;
        }
    }
    return root;
}

void insert(struct TreeNode **root, int key) {
    struct TreeNode **where = descend(root, key);
    if (!*where) {
        *where = calloc(1, sizeof(struct TreeNode));
        ...
        (*where)-&gt;data = key;
    }
}
</code></pre>
<hr />
<p>Sometimes fixed-size buffers are inconvenient:</p>
<pre><code class="language-c">char buf[100];
// scanf(&quot;%s&quot;, buf); &lt;- banned
scanf(&quot;%99s&quot;, buf);
...
snprintf(buf, sizeof(buf), &quot;%d bottles of beer on the wall&quot;, 50)
...
fgets(buf, sizeof(buf), stdin);
// gets(buf);  &lt;- banned from C11
</code></pre>
<hr />
<pre><code class="language-c">char *buf = NULL;
scanf(&quot;%ms&quot;, &amp;buf); // POSIX
...
free(buf);
</code></pre>
<pre><code class="language-c">char *buf = NULL;
asprintf(&amp;buf,
         &quot;%d little Soldier Boys &quot;
         &quot;went out to dine&quot;, 10); // GNU / BSD
...
free(buf);
</code></pre>
<pre><code class="language-c">// ssize_t getline(char **lineptr, size_t *n, FILE *stream);
char *line = NULL;
size_t linesize = 0;
getline(&amp;line, &amp;linesize, stdin); // POSIX
...
free(line);
</code></pre>
<hr />
<p><img src="11-c-continued/ptr-conv1.png" alt="w:1000" />
<img src="11-c-continued/ptr-conv2.png" alt="w:1000" /></p>
<hr />
<p><img src="11-c-continued/no-restrict.png" alt="w:1000" /></p>
<hr />
<p><img src="11-c-continued/restrict.png" alt="w:1000" /></p>
<hr />
<p>Strict aliasing
<img src="11-c-continued/aliasing.png" alt="w:1000" /></p>
<hr />
<p>Union types</p>
<pre><code class="language-c">union U {
    uint32_t u;
    float f;
    char bytes[4];
}

assert(sizeof(union U) == 4);
</code></pre>
<hr />
<p>Glibc malloc</p>
<p><img src="11-c-continued/glibc-malloc.png" alt="w:1000" /></p>
<hr />
<ul>
<li>
<p>C++'s <code>new</code> uses malloc</p>
</li>
<li>
<p>Python: malloc + reference counting + GC</p>
</li>
<li>
<p>Go, Java: garbage collection</p>
</li>
</ul>
<hr />
<ul>
<li>Overcommit. OOM killer.</li>
<li>Memory leaks, double free, use after free.</li>
</ul>
<hr />
<p>Address sanitizer</p>
<pre><code class="language-bash">gcc -fsanitize=address myprog.c
</code></pre>
<hr />
<p>Valgrind</p>
<pre><code>Valgrind is in essence a virtual machine using just-in-time
(JIT) compilation techniques, including dynamic
recompilation. Nothing from the original program ever gets
run directly on the host processor. Instead, Valgrind first
translates the program into a temporary, simpler form called
Intermediate Representation (IR), which is a
processor-neutral, SSA-based form. ...

...usually, code run with Valgrind ...runs at 20% to 25% of
the speed of the normal program.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="bits-and-pieces"><a class="header" href="#bits-and-pieces">Bits and pieces</a></h2>
<p>Иногда хочется работать с отдельными битами внутри значения.</p>
<p>Вспомним кодировку UTF-8:</p>
<pre><code class="language-c">0xxxxxxx — cимвол ASCII
110xxxxx 10xxxxxx
1110xxxx 10xxxxxx 10xxxxxx
11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
</code></pre>
<p>Операторы сдвига я языке Си:</p>
<pre><code class="language-c">x &lt;&lt; n
x &gt;&gt; n
</code></pre>
<p>Undefined behaviour, если:</p>
<blockquote>
<p>— An expression is shifted by a negative number or by an amount greater than or equal to the width of the promoted expression (6.5.7).
— An expression having signed promoted type is left-shifted and either the value of the expression is negative or the result of shifting would be not be representable in the promoted type (6.5.7).</p>
</blockquote>
<p>Например:</p>
<pre><code class="language-c">7 &lt;&lt; 2           // 28
7 &lt;&lt; -1          // UB
7 &lt;&lt; 30          // на нашей платформе UB
-1 &gt;&gt; 1          // implementation defined
0xABCDEFFFu &lt;&lt; 4 // 0xBCDEFFF0u
0 &lt;&lt; 32          // на нашей платформе UB
</code></pre>
<p>Давайте пробовать классифицировать байты из UTF-8:</p>
<pre><code class="language-c">_Bool is_ascii(char b) {
    // return (b &gt;&gt; 7) == 0; // nope, could be signed char
    return ((unsigned char) b &gt;&gt; 7) == 0;
}

_Bool is_continuation(unsigned char b) {
    // return (b &gt;&gt; 6) == 0b10; // valid in C++14
    return (b &gt;&gt; 6) == 2;
}

_Bool is_2_byte_start(unsigned char b) {
    return (b &gt;&gt; 5) == 6; // 0b110
}
</code></pre>
<p>Вместо сдвигов можно воспользоваться битовыми масками:</p>
<pre><code class="language-c">_Bool is_2_byte_start(unsigned char b) {
    return (b &amp; 0xE0) == 0xC0; // 0b1110'0000, 0b1100'0000
}
</code></pre>
<p>Битовые поля:</p>
<pre><code class="language-c">struct u8char {
    uint8_t sign_bit : 1;
    uint8_t tail_bits : 7;
}

union char_breaker {
    uint8_t number;
    struct u8char fields;
}

...
union char_breaker cb = {.number = 'x'};
cb.fields.sign_bit; // implementation defined if this is the sign bit :-(
</code></pre>
<h2 id="setjmp--longjmp"><a class="header" href="#setjmp--longjmp"><code>setjmp</code> / <code>longjmp</code></a></h2>
<pre><code class="language-c">#include &lt;setjmp.h&gt;
int setjmp(jmp_buf env);
void longjmp(jmp_buf env);
</code></pre>
<h2 id="inline-assembly"><a class="header" href="#inline-assembly">Inline assembly</a></h2>
<p><a href="https://gcc.gnu.org/onlinedocs/gcc/Using-Assembly-Language-with-C.html">Документация GCC</a></p>
<pre><code class="language-c">// Basic asm
asm(&quot;nop&quot;);

// Extended asm
// asm(template : outputs : inputs : clobbers)
</code></pre>
<p><a href="https://www.opennet.ru/base/dev/gccasm.txt.html">Какое-то красивое подробное описание</a></p>
<pre><code>g - general effective address
m - memory effective address
r - register
i - immediate value, 0..0xffffffff
n - immediate value known at compile time.
    (&quot;i&quot; would allow an address known only at link time)

But there are some i386-specific ones described in the processor-specific
part of the manual and in more detail in GCC's i386.h:

q - byte-addressable register (eax, ebx, ecx, edx)
A - eax or edx
a, b, c, d, S, D - eax, ebx, ecx, edx, esi, edi respectively

I - immediate 0..31
J - immediate 0..63
K - immediate 255
L - immediate 65535
M - immediate 0..3 (shifts that can be done with lea)
N - immediate 0..255 (one-byte immediate value)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git"><a class="header" href="#git"><code>git</code></a></h1>
<pre><code>$ whatis git | grep stupid
git(1)                   - the stupid content tracker
</code></pre>
<p><a href="https://xkcd.com/1597/">xkcd, объясняющий, как устроена лекция</a></p>
<p><a href="https://git.github.io/git-scm.com/book/en/v2">The Pro Git book</a></p>
<h2 id="tracking-work-on-projects"><a class="header" href="#tracking-work-on-projects">Tracking work on projects</a></h2>
<p>Создадим <em>репозиторий</em> — директорию, в которой будет храниться исходный код нашего проекта:</p>
<pre><code class="language-shell">~$ mkdir chaos
~$ cd chaos
chaos$ git init -b main
Initialized empty Git repository in /home/myltsev/chaos/.git/
</code></pre>
<p>Напишем для нашего проекта README и сохраним его с помощью git:</p>
<pre><code>chaos$ echo 'A project to develop a new operating system.' &gt;README
chaos$ git add README
chaos$ git commit -m 'Add README.'

[main (root-commit) 12328ce] Add README.
 1 file changed, 1 insertion(+)
 create mode 100644 README
</code></pre>
<p>Так началась история нашего проекта:</p>
<pre><code>chaos$ git log

commit 12328ce18536e38c3d2a6921a953b0bea7ef1eeb (HEAD -&gt; main)
Author: Alexander Myltsev &lt;a.myltsev@gmail.com&gt;
Date:   Fri Jan 12 18:46:40 2024 +0400

    Add README.
</code></pre>
<p>Добавим ещё файл, чтобы в истории проекта было два разных записанных момента:</p>
<pre><code>chaos$ touch main.c
chaos$ git add main.c
chaos$ git commit

[main f5c5cbf] Start actual programming.
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 main.c
</code></pre>
<h2 id="beautiful-tree-model"><a class="header" href="#beautiful-tree-model">Beautiful tree model</a></h2>
<p>Посмотрим, как именно git хранит содержимое нашего файла. Он приписывает спереди
к содержимому <code>&quot;blob ДЛИНА\0&quot;</code> и берёт от результата хэш SHA-1, а потом
складывает содержимое в соответствующий файл на диске:</p>
<pre><code>chaos$ echo -e 'blob 45\0A project to develop a new operating system.' | sha1sum
e750a68af1f2f3712d7f43ad5d64a8d363b2568f  -

chaos$ ls .git/objects/e7
50a68af1f2f3712d7f43ad5d64a8d363b2568f

chaos$ python3 -c 'import zlib; print(zlib.decompress(open(&quot;.git/objects/e7/50a68af1f2f3712d7f43ad5d64a8d363b2568f&quot;, &quot;rb&quot;).read()))'
b'blob 45\x00A project to develop a new operating system.\n'
</code></pre>
<p>Таким образом, git использует content-addressable storage: данное содержимое
файла всегда хранится под одним и тем же именем. Директория будет храниться как
список имён файлов с указанием хешей их содержимого:</p>
<pre><code>chaos$ git cat-file -p bd452a89d490ea711965f9688cc60559afd25e33
100644 blob e750a68af1f2f3712d7f43ad5d64a8d363b2568f    README
100644 blob e69de29bb2d1d6434b8b29ae775ad8c2e48c5391    main.c
</code></pre>
<p>Коммит (записанный момент в истории) хранится как ссылка на корневую директорию
и набор метаинформации (имя автора, метка времени, описание коммита,
идентификатор родительского коммита и др.):</p>
<pre><code>chaos$ git cat-file -p HEAD
tree bd452a89d490ea711965f9688cc60559afd25e33
parent 12328ce18536e38c3d2a6921a953b0bea7ef1eeb
author Alexander Myltsev &lt;a.myltsev@gmail.com&gt; 1705074661 +0400
committer Alexander Myltsev &lt;a.myltsev@gmail.com&gt; 1705074661 +0400

Start actual programming.
</code></pre>
<p>Таким образом, объекты в хранилище, ссылаясь друг на друга,
образуют ациклический направленный граф (DAG).</p>
<p>У нас в репозитории сейчас два коммита,
но один из них имеет специальное значение: он «самый актуальный»,
соответствует состоянию рабочей копии и станет родителем
следующего коммита. Этот коммит будем называть головным (<code>HEAD</code>).</p>
<p>Скорее всего нам потребуется в разные моменты времени считать головным разные
коммиты — например, мы хотим работать над несколькими задачами, переключаясь
между ними, и каждой задаче соответствует своя последовательность вносимых
изменений. Понятно, как это сделать: запишем идентификаторы этих коммитов в файлы с
понятными именами в директории <code>heads</code> и дадим пользователю возможность
обращаться к коммитам по этим именам.</p>
<p>Посмотрим, какие <code>heads</code> есть сейчас в нашем репозитории:</p>
<pre><code>$ ls .git/refs/heads
main
$ cat .git/refs/heads/main
f5c5cbf218fe113a1fa282b6c8046a245d5a07a6
</code></pre>
<p>А вот какой head на самом деле является сейчас головным коммитом:</p>
<pre><code>$ cat .git/HEAD
ref: refs/heads/main
</code></pre>
<p>Каждый <code>head</code>-коммит вместе с цепочкой его предшественников принято называть
<em>веткой</em> разработки (branch).</p>
<p>Теперь у нас есть возможность обращаться к коммитам как по их SHA1-хэшу,
так и по названиям из <code>heads</code>. Чтобы добыть хэш коммита по имени, есть утилита
<code>git rev-parse</code>:</p>
<pre><code>$ git rev-parse main
f5c5cbf218fe113a1fa282b6c8046a245d5a07a6
$ git rev-parse HEAD
f5c5cbf218fe113a1fa282b6c8046a245d5a07a6
</code></pre>
<p>На самом деле SHA1-хэш необязательно писать полностью — достаточно уникального префикса:</p>
<pre><code>$ git rev-parse f5c5
f5c5cbf218fe113a1fa282b6c8046a245d5a07a6
</code></pre>
<p>Есть также нотация для обращения к родительским коммитам:</p>
<pre><code>$ git rev-parse HEAD^  # ^ — первый родитель
12328ce18536e38c3d2a6921a953b0bea7ef1eeb
$ git rev-parse HEAD~1  # ~n — n-тый прародитель
12328ce18536e38c3d2a6921a953b0bea7ef1eeb
</code></pre>
<h2 id="just-memorize-these-shell-commands"><a class="header" href="#just-memorize-these-shell-commands">Just memorize these shell commands</a></h2>
<h3 id="branches"><a class="header" href="#branches">branches</a></h3>
<p>Создадим дополнительную ветку разработки из предыдущего коммита:</p>
<pre><code>$ git switch -c feature HEAD^
Switched to a new branch 'feature'
</code></pre>
<p>Теперь у нас две ветки, из которых активна ветка <code>feature</code>:</p>
<pre><code>$ git branch
* feature
  main

$ ls
README
</code></pre>
<p>Как видно, в этом коммите ещё нет файла <code>main.c</code>.</p>
<p>С помощью <code>git switch</code> можно переключаться между ветками:</p>
<pre><code>chaos$ git switch main
Switched to branch 'main'

chaos$ ls
README main.c
</code></pre>
<p>Сейчас история коммитов выглядит так:
<img src="ipr/gitlog.png" alt="git log screenshot" /></p>
<p>Переключимся на ветку <code>feature</code> и сделаем там новый коммит:</p>
<pre><code>$ git switch feature
Switched to branch 'feature'

$ echo '#include &lt;stdio.h&gt;' &gt;main.c

$ git add main.c

$ git commit -m 'Include stdio.h.'
[feature 6a83b31] Include stdio.h.
 1 file changed, 1 insertion(+)
 create mode 100644 main.c
</code></pre>
<p>Теперь у нас есть две ветки, которые не являются предками
друг друга (diverging branches):
<img src="ipr/git-log-graph.png" alt="" /></p>
<h3 id="index"><a class="header" href="#index">index</a></h3>
<p>В рабочей копии могут быть файлы, которые git не отслеживает, —
например, объектные, исполняемые и временные файлы.
Кроме того, не все изменения в отслеживаемых файлах обязаны
включаться в следующий коммит.</p>
<p>Чтобы подготовить содержимое следующего коммита, в <code>git</code> есть
<em>индекс</em> (index или <em>staging area</em>). Получается такой маршрут:</p>
<ol>
<li>Правим файлы в рабочей копии (<code>vim</code>).</li>
<li>Копируем изменения в индекс (<code>git add</code> и др.).</li>
<li>Создаём коммит с содержимым индекса (<code>git commit</code>).</li>
</ol>
<p>Попробуем сделать изменения, но не добавлять их в индекс,
а сразу сделать новый коммит:</p>
<pre><code>$ echo '#include &lt;stdlib.h&gt;' &gt;&gt;main.c

$ git commit
On branch main
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)
        modified:   main.c

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>Наши изменения сейчас есть только в рабочей копии, но не в индексе:
<img src="ipr/git-diff.png" width="250"/></p>
<p>Добавим их в индекс и создадим новый коммит:</p>
<pre><code>chaos$ git add main.c

chaos$ git diff --cached --stat
 main.c | 1 +
 1 file changed, 1 insertion(+)

chaos$ git commit -m 'Include stdlib.h.'
[main 16b1dc9] Include stdlib.h.
 1 file changed, 1 insertion(+)
</code></pre>
<p>Можно добавлять в индекс не все изменения в файле,
например, с помощью интерактивной команды <code>git add -p</code>
(она будет спрашивать вас отдельно про каждое изменение).</p>
<p>Восстановить содержимое индекса из <code>HEAD</code> можно
с помощью <code>git restore --staged [-p]</code>.</p>
<p>Все изменения в отслеживаемых файлах можно закоммитить
с помощью <code>git commit -a</code>.</p>
<h3 id="merging"><a class="header" href="#merging">merging</a></h3>
<p>Для слияния изменений в разных ветках имеется команда <code>git merge</code>.
Попытаемся учесть в <code>main</code> изменения, сделанные в <code>feature</code>.</p>
<pre><code>$ git merge feature
Auto-merging main.c
CONFLICT (add/add): Merge conflict in main.c
Automatic merge failed; fix conflicts and then commit the result.
</code></pre>
<p>git не знает, как объединить изменения, сделанные в двух ветках.
Поэтому он оставляет в файле <code>main.c</code> маркеры конфликта,
а сам файл в индексе помечен как unmerged:</p>
<pre><code>chaos$ cat main.c 
««««««« HEAD
#include &lt;stdlib.h&gt;
=======
#include &lt;stdio.h&gt;
»»»»»»» feature

chaos$ git status
On branch main
You have unmerged paths.
  (fix conflicts and run &quot;git commit&quot;)
  (use &quot;git merge --abort&quot; to abort the merge)

Unmerged paths:
  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)
        both added:      main.c

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
</code></pre>
<p>Чтобы завершить слияние, нужно отредактировать unmerged
файлы и добавить в индекс их правильные версии, а затем
создать коммит:</p>
<pre><code>$ vim main.c 
$ git add main.c
$ git commit
[main 3a4c639] Merge branch 'feature'
</code></pre>
<p>Созданный коммит является слиянием (merge commit),
то есть имеет больше одного родителя:</p>
<pre><code>$ git show
commit 3a4c6391190b85c8c4f9d19177d464b0acce5b36 (HEAD -&gt; main)
Merge: 16b1dc9 6a83b31
...
</code></pre>
<p><code>git log --graph</code> отображает это соответствующим образом:
<img src="ipr/merge-graph.png" alt="" /></p>
<p>Попробуем теперь сделать обратное слияние: добавить
в feature изменения, сделанные в main.</p>
<pre><code>$ git switch feature
Switched to branch 'feature'

chaos$ git merge main
Updating 6a83b31..3a4c639
Fast-forward
 main.c | 1 +
 1 file changed, 1 insertion(+)
</code></pre>
<p>Поскольку <code>feature</code> была предком <code>main</code>, слияние произошло
более простым способом — <code>feature</code> теперь просто является синонимом
<code>main</code>:
<img src="ipr/fast-forward.png" alt="" /></p>
<p>Такой способ слияния называется <em>перемоткой</em> (fast forward).
Нового коммита при этом не создаётся.</p>
<h3 id="remotes"><a class="header" href="#remotes">remotes</a></h3>
<p>Для взаимодействия с другими репозиториями существует механизм
<code>remotes</code>. Я сделал себе пустой репозиторий на <code>gitlab.myltsev.ru</code>
и добавляю его как remote с именем <code>origin</code>:</p>
<pre><code>$ git remote add origin git@gitlab.myltsev.ru:myltsev/chaos.git
</code></pre>
<p>Отправим туда нашу ветку <code>main</code>:</p>
<pre><code>$ git push origin main
Enumerating objects: 15, done.
Counting objects: 100% (15/15), done.
Delta compression using up to 8 threads
Compressing objects: 100% (9/9), done.
Writing objects: 100% (15/15), 1.28 KiB | 1.28 MiB/s, done.
Total 15 (delta 1), reused 0 (delta 0), pack-reused 0
To ssh://gitlab.myltsev.ru/myltsev/chaos.git
 * [new branch]      main -&gt; main
</code></pre>
<p>Можно добавлять новые коммиты в ветку <code>main</code> и отправлять их туда же той же
командой. Если, как правило, мы будем
отправлять коммиты из <code>main</code> именно в эту ветку этого
remote, то имеет смысл сообщить git-у, что это ветка является
для <code>main</code> <em>апстримом</em>. Для этого добавим опцию <code>-u</code>/<code>--set-upstream</code>:</p>
<pre><code>$ git push -u origin main
branch 'main' set up to track 'origin/main'.
Everything up-to-date
</code></pre>
<p>В файле <code>.git/config</code> появилась соответствующая запись:</p>
<pre><code>[branch &quot;main&quot;]
    remote = origin
    merge = refs/heads/main
</code></pre>
<p><code>git push</code> будет по умолчанию работать именно с апстримной веткой.</p>
<p>В локальном репозитории хранятся копии головных коммитов из remotes:</p>
<pre><code>$ cat .git/refs/remotes/origin/main 
3a4c6391190b85c8c4f9d19177d464b0acce5b36
</code></pre>
<p><code>git switch</code> умеет догадываться о том, что локальную ветку нужно создать из
remote-ветки с таким же названием:</p>
<pre><code>$ git switch tmp
branch 'tmp' set up to track 'origin/tmp'.
Switched to a new branch 'tmp'
</code></pre>
<p><code>git fetch</code> обновляет <code>refs/remotes</code> и приносит
в локальное хранилище недостающие объекты.</p>
<p><code>git pull</code> — это сочетание <code>fetch + merge</code>:
обновить локальные копии remote-коммитов и провести слияние.
Если локально новых коммитов в ветке нет, а в remote они появились,
то fetch принесёт их в локальный репозиторий, а merge
сведётся к перемотке:</p>
<pre><code>$ git pull
Updating 3a4c639..20992d8
Fast-forward
 main.c | 4 ++++
 1 file changed, 4 insertions(+)
</code></pre>
<p><code>git push</code> по умолчанию работает, только если remote-ветка
является предком локальной (то есть её можно перемотать
до локальной). Если remote-ветка и локальная ветка не являются
предками друг друга (divergent branches), то <code>push</code>
отказывается работать:</p>
<pre><code>$ git push
To ssh://gitlab.myltsev.ru/myltsev/chaos.git
 ! [rejected]        main -&gt; main (fetch first)
error: failed to push some refs to 'ssh://gitlab.myltsev.ru/myltsev/chaos.git'
hint: Updates were rejected because the remote contains work that you do not
hint: have locally. This is usually caused by another repository pushing to
hint: the same ref. If you want to integrate the remote changes, use
hint: 'git pull' before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.
</code></pre>
<p>Беда в том, что по умолчанию git pull в этой ситуации тоже
по умолчанию ведёт себя несговорчиво:</p>
<pre><code>$ git pull
remote: Enumerating objects: 5, done.
remote: Counting objects: 100% (5/5), done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 1), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), 281 bytes | 140.00 KiB/s, done.
From ssh://gitlab.myltsev.ru/myltsev/chaos
   20992d8..f54e8cf  main       -&gt; origin/main
hint: You have divergent branches and need to specify how to reconcile them.
hint: You can do so by running one of the following commands sometime before
hint: your next pull:
hint: 
hint:   git config pull.rebase false  # merge
hint:   git config pull.rebase true   # rebase
hint:   git config pull.ff only       # fast-forward only
hint: 
hint: You can replace &quot;git config&quot; with &quot;git config --global&quot; to set a default
hint: preference for all repositories. You can also pass --rebase, --no-rebase,
hint: or --ff-only on the command line to override the configured default per
hint: invocation.
fatal: Need to specify how to reconcile divergent branches.
</code></pre>
<p>Безопасным вариантом в данном случае является опция
<code>--no-rebase</code>, которая выполнит слияние локальной и удалённой
ветки.</p>
<h3 id="rebasing"><a class="header" href="#rebasing">rebasing</a></h3>
<p>⚠ Here be dragons!</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Операционная-система"><a class="header" href="#Операционная-система">Операционная система</a></h2>
<p>Комплекс программ.</p>
<p>Организует доступ к ресурсам ЭВМ:</p>
<ul>
<li>унифицирует,</li>
<li>разграничивает,</li>
<li>мультиплексирует,</li>
<li>учитывает и квотирует.</li>
</ul>
<p>Для всего этого требуется привилегированный режим
работы процессора.
Часть ОС, использующую этот режим, принято называть <em>ядром</em>
(kernel).</p>
<p>Ядро бывает:</p>
<ul>
<li>монолитное,</li>
<li>модульное (например, Linux),</li>
<li>микроядро (microkernel).</li>
</ul>
<h2 id="Взаимодействие-с-устройствами"><a class="header" href="#Взаимодействие-с-устройствами">Взаимодействие с устройствами</a></h2>
<p>Memory-mapped и port-mapped IO.</p>
<p><img src="system_bus.png" alt="" /></p>
<p>Например, видеопамять </p>
<p>Работа с портами: инструкции <a href="https://www.felixcloutier.com/x86/in">in</a>, <a href="https://www.felixcloutier.com/x86/out">out</a>.</p>
<p>Например, VGA использует, кроме прочих, порты 0x3d4 и 0x3d5.</p>
<p>Polling.</p>
<h2 id="Загрузка-компьютера-с-bios"><a class="header" href="#Загрузка-компьютера-с-bios">Загрузка компьютера с BIOS</a></h2>
<p>(сейчас на вашем x86-совместимом компьютере UEFI, но идея та же)</p>
<p>Часть адресов RAM отображена на ROM, где лежит firmware.</p>
<p><a href="https://wiki.osdev.org/Memory_Map_(x86)">Структура адресуемой памяти x86</a></p>
<p>При включении компьютера процессор работает в режиме совместимости
с IBM PC (16-битный <em>real mode</em>), исполнение начинается
по адресу 0xFFFF0 (<em>reset vector</em>).</p>
<h3 id="Сегментная-модель-памяти--"><a class="header" href="#Сегментная-модель-памяти--">Сегментная модель памяти :-(</a></h3>
<p>IBM PC мог адресовать 1 MB памяти (20-битная шина адреса),
а регистры были 16-битные.</p>
<p>Сегментные регистры: <code>cs</code>, <code>ds</code>, <code>es</code>, <code>ss</code> (<code>fs</code>, <code>gs</code> в 32-битном режиме).</p>
<p>Каждое обращение к памяти происходит по адресу из двух частей:
сегментные регистр и смещение. Физический адрес равен <code>16 * seg + offset</code>.</p>
<pre><code class="language-x86asm">    mov [ds:ax], 42  // обращение к памяти по адресу 16 * ds + ax
</code></pre>
<h3 id="Загрузка-с-диска"><a class="header" href="#Загрузка-с-диска">Загрузка с диска</a></h3>
<p>BIOS инициализирует и тестирует оборудование компьютера,
а затем читает с загрузочного диска первый <em>сектор</em> (512 байт)
и передаёт ему управление.</p>
<h2 id="Учебная-ОС-yabloko"><a class="header" href="#Учебная-ОС-yabloko">Учебная ОС yabloko</a></h2>
<p><a href="https://github.com/hse-cs-ami/yabloko-public">Гитхаб</a>.</p>
<p>Учебную операционную систему мы запускаем в эмуляторе. Скрипт установки под macOS и Linux находится в файле <code>setup.sh</code>.</p>
<p>Среди файлов есть <code>mbr.S</code> (master boot record). Он должен умещаться в 512 байт и будет складываться в первый сектор эмулируемого жесткого диска.</p>
<h3 id="drivers"><a class="header" href="#drivers">DRIVERS</a></h3>
<p>В  <code>drivers/port.h</code> лежат обертки port-mapped IO для языка C, написанные в виде ассемблерных вставок:</p>
<pre><code class="language-c">static inline unsigned char port_byte_in(unsigned short port) {
    unsigned char result;
		// инструкция in, берет номер порта из регистра %dx, а кладёт результат в регистр %al
    __asm__(&quot;in %%dx, %%al&quot; : &quot;=a&quot; (result) : &quot;d&quot; (port));
    return result;
}
</code></pre>
<p>Нам нужно что-то печатать на экран, для этого есть <code>drivers/vga.h</code> и <code>drivers/vga.с</code> для работы со стандартным графическим адаптером VGA. Когда компьютер загружается, экран работает в текстовом режиме и содержит 25 строк и 80 столбцов. Линейно лежат пары байт: в одном — символ, в другом — цвет фона и цвет самого символа. Символы нумеруются построчно начиная с левого верхнего края экрана.</p>
<pre><code class="language-c">char* const video_memory = (char*) 0xb8000; // видео-память отображена по адресу 0xb8000 (memory-mapped IO)

void vga_set_char(unsigned offset, char c) {
    video_memory[2 * offset] = c;                                  // сам символ
    video_memory[2 * offset + 1] = get_color(light_gray, black);   // цвет; пишем светло-серым по черному
}
</code></pre>
<p>Так как мы не всегда будем пользоваться эмулятором в графическом режиме (не всегда будет настоящий монитор), необходимо эмулировать также последовательный порт, способный передавать байты. Код в <code>drivers/uart.h</code> и <code>drivers/uart.c</code></p>
<h3 id="kernel"><a class="header" href="#kernel">KERNEL</a></h3>
<p>Посмотрим на <code>kernel.c</code>:</p>
<pre><code class="language-c">void _start() {
    uartinit();                  // запускаем последовательный порт

    vga_clear_screen();          // очищаем экран
    printk(&quot;\nYABLOKO\n&quot;);       // выводим текст
    asm(&quot;hlt&quot;);                  // остановиться и ничего не делать
}
</code></pre>
<p>Заметим несколько вещей в <code>kernel.c</code>:</p>
<ol>
<li>Функция <code>vga_clear_screen()</code> заполняет весь экран пробелами.</li>
<li><code>printk(&quot;\nYABLOKO\n&quot;)</code> выводит текст не только на экран, но и на последовательный порт. На данный момент у нас не реализованы прокрутка экрана и курсор; мы не умеем работать с клавиатурой и вводом.</li>
<li>У нас нет способа выключить компьютер; нам придется делать это платформо-специфичным путём с помощью <code>qemu_shutdown()</code> </li>
</ol>
<p>Существует две реализации языка C:</p>
<ul>
<li>Hosted реализация подразумевает, что есть операционная система, есть стандартная библиотека языка C и реализованные в ней функции. На эту реализацию мы рассчитываем при запуске компилятора gcc.</li>
<li>Freestanding реализация используется для ядра, подразумевает, что мы работаем без операционной системы, сами организуем загрузку бинарника и начало исполнения в нужной точке. Особенность freestanding режима — отсутствие функции main(); пишем _start — это стандартное название для точки входа в ELF-бинарник. При сборке передаем опцию <code>-ffreestanding</code>, чтобы работать именно с этой реализацией.</li>
</ul>
<p>Так же важный момент сборки <code>-Ttext 0x1000</code> — мы указываем, с какого адреса начинается секция <code>text</code>. В адресуемой памяти x86 этот адрес как раз попадает в диапазон usable memory. </p>
<h3 id="master-boot-record"><a class="header" href="#master-boot-record">MASTER BOOT RECORD</a></h3>
<p>BIOS читает загрузчик в память по адресу 0x7c00 и на этот же адрес передает выполнение. Задача — скомпоновать mbr так, чтобы он с этого адреса начинался.</p>
<p>Чтобы запустить под отладчиком целый компьютер, нужен следующий кусок в Makefile</p>
<pre><code class="language-makefile">debug-boot-nox: image.bin mbr.elf
	qemu-system-i386 -nographic -drive format=raw,file=$&lt; **-s -S** &amp;  // &quot;взаимодействуй с отладчиком и подожди, пока отладчик подключится&quot;
	$(GDB) mbr.elf \
		-ex &quot;set architecture i8086&quot; \                               // архитектура 8086 (16-битная архитектура)
		-ex &quot;target remote localhost:1234&quot; \                         // эмулятор по адресу localhost:1234 запустит gdb сервер и будет ждать, когда подключится отладчик 
		-ex &quot;break *0x7c00&quot; \                                        // breakpoint на адрес входа в загрузчик
		-ex &quot;continue&quot;                                               // продолжить исполнение
</code></pre>
<p>Посмотрим ближе на mbr.S под отладчиком:</p>
<pre><code class="language-x86asm">.code16
    .global _start
_start:
// по договоренностям в %dl BIOS передает загрузчику номер диска,
// с которого он загрузчик прочитал; поэтому этот регистр сохраняется в boot_drive
    mov %dl, boot_drive                     
    mov $banner, %si
    call print_string                         // посимвольная печать banner

    call get_drive_geometry
    call load_kernel
    call switch_to_32bit

    hlt
    jmp . // loop forever
</code></pre>
<p>Для ввода-вывода в загрузчике используются функции BIOS. Пример можно увидеть в <code>print_string</code>: в регистр <code>%ah</code> кладётся магическое значение 0x0e, а в <code>%al</code> кладется символ; при вызове  <code>int $0x10</code> символ печатается на экран. Следующий код печатает посимвольно строку:</p>
<pre><code class="language-x86asm">.code16
print_string:
    mov $0x0e, %ah  // &quot;teletype output&quot;
repeat:
    lodsb           // equivalent to mov (%si), %al; inc %si

    test %al, %al
    je done

    int $0x10       // bios interrupt
    jmp repeat
done:
    ret
</code></pre>
<p>В <code>fs/fs.h</code> описана структура файловой системы: первый сектор она использует для собственных нужд, со следующего сектора начинается первый файл. Пока что у нас один файл kernel.bin, он находится начиная с третьего сектора диска.</p>
<pre><code>/* Directory structure:
         32-byte entries
┌───────────────────────────────┐
│Reserved                       │
│char[32]                       │
├──────┬──────┬────────┬────────┤
│Offset│Size  │Reserved│Name    │
│uint32│uint32│uint32  │char[20]│
├──────┼──────┼────────┼────────┤
│ ...  │      │        │        │
Offset is in sectors (zero-based),
size is in bytes, name is 0-terminated.
*/
</code></pre>
<p>Результирующий образ диска состоит из загрузочного сектора и файловой системы.</p>
<p>Так как нет встроенного драйвера жесткого диска, мы читаем с диска секторы с ядром с помощью BIOS, как и загрузчик. Реализация находится в функции <code>load_kernel</code> в <code>mbr.S</code>. Результат работы этой функции:</p>
<ul>
<li>В памяти оказывается ядро (то, что идёт после заголовка в ELF-файле)</li>
<li>В переменной entry оказывается адрес точки входа, на которую мы позже будем передавать управление.</li>
</ul>
<p>Чтобы загрузить ELF-файл нам надо прочитать программные заголовки и для каждого из них загрузить секцию по соответствующему адресу. Но у нас это реализовано по-другому: мы рассчитываем, что ELF-файл можно загрузить в память одним куском без разграничения доступа, защиты памяти. Мы также находимся в 16-битном режиме и используем функции BIOS (см. <code>int 0x13</code>)</p>
<p>После <code>load_kernel</code> мы переходим в 32-битный режим, так как ядро мы собирали как 32-битный бинарник. Поскольку IBM PC умел адресовать только 1Мб памяти, у него было 20 дорожек на адресной шине ($2^{20}$ байт = 1 Мбайт): A0-A19. С появлением компьютеров, способных адресовать большее количество памяти, возникла проблема совместимости:  старый софт рассчитывал, что в адресе больше 1Мб старшие биты адреса обрезаются. Для того чтобы вывести компьютер из этого режима совместимости, нужно провести некоторые манипуляции (первые две строки функции):</p>
<pre><code class="language-x86asm">switch_to_32bit:
    mov	$2, %al
    out	%al, $0x92          // enable A20

    cli                     // 1. disable interrupts

// в процессоре есть специальный регистр, указывающий на gdt, и мы загружаем таблицу в него:
    lgdt gdt_descriptor     // 2. load GDT descriptor

// меняем младший бит в регистре %cr0; так мы переходим из real mode в protected
    mov %cr0, %eax
    or $1, %eax             // 3. enable protected mode
    mov %eax, %cr0

// мы не можем загрузить %cs напрямую с помощью mov, поэтому пользуемся long jump - он загружает %cs и %eip
    ljmp $SEG_KCODE &lt;&lt; 3, $init_32bit // 4. far jump
</code></pre>
<p>Сегментные регистры cs, ds, cs, ds, ss, es, fs, gs теперь означают не смещение в памяти, а индекс в таблице дескрипторов (Global Descriptor Table) — структуре данных, где указаны сегменты и их особенности (например, код ядра должен исполняться только на высоком уровне привилегий; старый 16-битный код должен исполняться в режиме совместимости). Таблицу дескрипторов можно увидеть ниже:</p>
<pre><code class="language-x86asm">gdt_start:
    .quad 0x0                                // null descriptor, необходимость
    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)    // code seg, доступный на чтение и исполнение, адрес от 0x0 до 0xffffffff
    SEG_ASM(STA_W, 0x0, 0xffffffff)          // data seg, доступный на запись (и автоматически на чтение)
gdt_end:
</code></pre>
<p>То, как раскрываются макросы, можно посмотреть в <code>cpu/gdt.h</code></p>
<p>Переключившись в 32-битный режим, мы должны создать стек и переключиться на исполнение кода из <code>kernel.c</code>:</p>
<pre><code class="language-x86asm">mov $KERN_STACK_BASE, %ebp   // создание стека
    mov %ebp, %esp

    movzwl entry, %esi       // сохраненный адрес точки входа
    call *%esi               // переключение на исполнение кода ядра
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interrupts"><a class="header" href="#interrupts">Interrupts</a></h1>
<h3 id="Про-прерывания-в-общих-чертах"><a class="header" href="#Про-прерывания-в-общих-чертах">Про прерывания в общих чертах.</a></h3>
<p>В процессоре есть механизм (Traps), который наша операционная система использует и который обслуживает следующие три вещи:</p>
<ol>
<li>
<p>Hardware interrupts (Аппаратные прерывания).</p>
</li>
<li>
<p>Exception (Исключительные ситуации).</p>
</li>
<li>
<p>Software interrupts (Программные прерывания).</p>
</li>
</ol>
<p>Чего мы в принципе хотим добиться, используя этот механизм? Представим следующую ситуацию:</p>
<pre><code class="language-nasm">mov ...
nop &lt;---- eip
add ...

key_pressed:
	in $KEYBOARD_PORT, %al // кладём в какой-то буффер.
	iret // чо пон мниная единица * ret?? (выясним позже, что это такое)
</code></pre>
<p>Наша программа исполняет какие-то инструкции и тут в этом время пользователь жмёт кнопку на клавиатуре. Мы договорились заранее с процессором, что есть какой-то магический адрес key_pressed, на который во время прерывания должен перейти регистр eip, выполнить пару инструкций (положить нажатую кнопку в какой-то буффер, например) и прыгнуть обратно - исполнять код.</p>
<h3 id="Как-происходит-механизм-аппаратных-асинхронных-прерываний-схематически"><a class="header" href="#Как-происходит-механизм-аппаратных-асинхронных-прерываний-схематически">Как происходит механизм аппаратных (асинхронных) прерываний схематически?</a></h3>
<p>Примерно так:</p>
<ol>
<li>
<p>Во-первых, процессор должен откуда-то узнать, что пользователь нажал на клавиатуру.</p>
</li>
<li>
<p>Во-вторых, узнав об этом,  он должен где-то посмотреть - есть ли обработчик для данного события.</p>
</li>
<li>
<p>В-третьих, выяснив, что обработчик есть - он должен это как-то обработать, сохранив текущее состояние процессора (включая все регистры).</p>
</li>
<li>
<p>После обработки прерывания мы возвращаемся в наш код с помощью iret - инструкции, которая извлекает из стека три верхних значения и помещает их в регистры IP, CS и флагов. </p>
</li>
</ol>
<p>У процессора есть свой флаг в регистре флагов - IF (interrupt flag), который недоступен к модификации из пользовательских программ (не из пользовательских возможно с помощью cli и sti) .</p>
<p>Если IF взведён (то есть равен 1), то после каждой инструкции у процессора происходит проверка на наличие прерываний - если они есть, то происходит как раз тот самый механизм, который мы до этого обсуждали. </p>
<p>Если же IF не взведён (=0), то процессор просто не реагирует на маскируемые аппаратные прерывания и откладывает эту реакцию до более удобного момента.</p>
<h3 id="Про-остальное"><a class="header" href="#Про-остальное">Про остальное</a></h3>
<p>Программные прерывания и исключения обрабатываются тем же самым механизмом ловушек. </p>
<p>Вызвать программное прерывание можно с помощью ассемблерной инструкции int.</p>
<h3 id="interrupt-controller-Контроллер-прерываний"><a class="header" href="#interrupt-controller-Контроллер-прерываний">Interrupt Controller (Контроллер прерываний)</a></h3>
<p>Нам не хотелось бы обрабатывать приоритеты и очереди прерываний в самом процессоре, тем самым загружая его данной работой. Все эти обработки выносят в отдельную микросхему, которая называется interrupt controller. Мы будем пользоваться стандартом PIC (<em>Programmable Interrupt Controller</em>), который рассчитывает на то, что с ним работает один процессор. В современном компьютере все же устроено немного сложнее - там у каждого ядра процессора есть свой LAPIC (Local Advanded PIC), а глобально во всей системе есть IO APIC (Input Output APIC), который распределяет прерывания между ядрами.</p>
<p><img src="interrupts/Interrupts%20ec9425c586194a9899990eff69a46822/Untitled.png" alt="Untitled" /></p>
<p>Назревает сразу же вопрос - “Как же PIC узнает про то, что центральный процессор обработал прерывание и можно сбрасывать сигнал об этом прерывании и браться за следующее?”</p>
<p>Так вот, CPU взаимодействует с PIC с помощью Port Mapped IO — так и узнает.</p>
<h3 id="Как-устроены-прерывания-в-yabloko"><a class="header" href="#Как-устроены-прерывания-в-yabloko">Как устроены прерывания в Yabloko</a></h3>
<p>Мы не хотим поллить клавиатуру и постоянно спрашивать о том, не перенажал ли пользователь какую-то кнопку и хотим ловить прерывание, которое присылает клавиатура, обрабатывать его и выводить символ, который к нам приехал. Что нам для этого понадобится? Для этого нам нужна таблица обработчиков прерываний. Для каждого приходящего нам прерывания у нас есть структура idt_gate_t. Для каждого номера прерывания в таблице обработчиков (про природу этих номеров чуть дальше) хранится структура, которая соответствующим образом выстраивает работу с памятью. Посмотрим как выглядит таблица:</p>
<pre><code class="language-c">enum {
    IDT_HANDLERS = 256,
};

idt_gate_t idt[IDT_HANDLERS];
</code></pre>
<p>То есть сами прерывания приходят в виде номера int X → handler, где handler - это структура idt_gate_t idt[X] в нашей таблице. В целом, обработчик это код, который лежит по адресу памяти. Теперь посмотрим на структуру idt_gate_t:</p>
<pre><code class="language-c">typedef struct {
    uint16_t low_offset;
    uint16_t selector; // это поле содержит в себе номер сегмента, который 
// будет загружен в cs. Менять значение cs может потребоваться, когда мы 
// в пользовательском коде (режим с пониженными привилегиями) ловим прерывания,
// но обрабатываем их уже в ядре (режим с повышенными привилегиями).
    uint8_t always0;
    uint8_t type: 4; // : 4 - означает, что поле type занимает только 4 бита
// вместо 8
    uint8_t s: 1;
    uint8_t dpl: 2;
    uint8_t p: 1;
    uint16_t high_offset;
} __attribute__((packed)) idt_gate_t;
</code></pre>
<p>Мы работаем в 32-битном режиме и соответственно адрес у нас также 32-битный, поэтому мы режем наш адрес на две части: low_offset (раньше было так, что она была 16-битная и была только эта часть) и high_offset (то, что добавили потом).</p>
<p>Теперь поговорим про природу номеров прерываний, они же индексы в таблице прерываний. По-другому они называются векторами прерываний. Первые 32 вектора зарезервировал Intel, они же оставляют за собой право их доопределить до 32 (то есть до 31 номера) в следующих процессорах. Рассмотрим первые 19 из них, которые определены:</p>
<pre><code class="language-c">const char * const exception_messages[] = {
    [0] = &quot;Division By Zero&quot;,
    [1] = &quot;Debug&quot;,
    [2] = &quot;Non Maskable Interrupt&quot;,
    [3] = &quot;Breakpoint&quot;,
    [4] = &quot;Into Detected Overflow&quot;,
    [5] = &quot;Out of Bounds&quot;,
    [6] = &quot;Invalid Opcode&quot;, // на тот случай, когда процессор прочитал инстру-
// -кцию, а декодировать её не может (возможно какой-то мусор попался)
    [7] = &quot;No Coprocessor&quot;,

    [8] = &quot;Double Fault&quot;, // случай когда, произошла исключительная ситуация с
// номером от 0 до 7, но для неё не нашлось обработчика. Если обработчик не
// сработал и для Double Fault, то возникает уже Triple Fault и процессор
// перезагружается.
    [9] = &quot;Coprocessor Segment Overrun&quot;,
    [10] = &quot;Bad TSS&quot;,
    [11] = &quot;Segment Not Present&quot;,
    [12] = &quot;Stack Fault&quot;,
    [13] = &quot;General Protection Fault&quot;, // случай, когда не хватает прав для рабо-
// -ты с памятью, например, записываем что-то в read-only памяти. Эта же ситуация 
// может возникнуть при программировании ядра, когда мы не написали
// что-то для сегментов.
    [14] = &quot;Page Fault&quot;,
    [15] = &quot;Unknown Interrupt&quot;,

    [16] = &quot;Coprocessor Fault&quot;,
    [17] = &quot;Alignment Check&quot;,
    [18] = &quot;Machine Check&quot;,
};
</code></pre>
<p>Например, если процессор ловит исключительную ситуацию - “деление на 0”, он всегда возбуждает вектор прерывания с номером 0.</p>
<p>Дальше нам хотелось бы иметь векторы, которые работают с прерываниями у разных устройств компьютера. Схема этого процесса выглядит таким образом:</p>
<pre><code class="language-c">Device -&gt;&gt; PIC -&gt;&gt; CPU
</code></pre>
<p>Если что-то случилось с устройством компьютера, оно сигнализирует PIC об этом, PIC хранит информацию о том, что на устройстве было конкретное прерывание с конкретным номером и пока процессор не обработает его, PIC будет напоминать об этом CPU. Например, клавиатура, присоединенная на первой ноге к PIC, присылает IRQ1 (interrupt request - запрос на прерывание) на PIC, дальше PIC делает смещение относительно 0x20 для IRQ и уже на процессор приходит то, что вызван 33-й по счету вектор.</p>
<p>Как обрабатывает прерывания сам процессор? Посмотрим на код:</p>
<pre><code class="language-nasm">/*
* mov ... // IF = 1
* ------ // interrupt handling started
* push eflags
* push error_code
* push eip
* push cs
* cli
* ljmp handler_segment:handler_offset // cs, eip = handler_segment, handler_offset
*/
</code></pre>
<p>Пусть выполняется какая-то инструкция (например, mov) во время исполнения которой был взведён флаг IF (Interrupt flag), то есть процессор будет готов к обработке прерываний. Дальше процессор проверяет не сигналит ли PIC о наличии прерывания и если он действительно сигналит, то он начинает обрабатывать это прерывание. Процессор сразу же начинает в текущем стеке обработку прерывания, то есть сразу после исполнения mov. Процессор кладет значение флагов, error_code (код ошибки - доп. информация о ней), instruction pointer’а, cs и отключает прерывания инструкцией cli, которая сбрасывает флаг IF, чтобы обработчик не мог сразу быть прерван ещё раз новым прерыванием. Далее процессор смотрит в таблицу с гейтами, добывает оттуда новое значение cs и eip, загружает их. Потом мы переходим на сегмент и адрес прерывания, который лежит в таблице обработчиков. Остальные регистры в процессе мы не трогали и чтобы их не испортить нам придется их самим сохранить и восстановить, когда мы закончим обрабатывать прерывание. Есть проблема: ни в какой момент никуда не сохраняется номер вектора прерывания. Единственное, что от него зависит это пушить или нет код ошибки (error_code) и на какой хэндлер (handler_segment:handler_offset) переходить. Другой информации о том, какой вектор прерывания мы обрабатываем у нас нет.</p>
<h3 id="Обработчики"><a class="header" href="#Обработчики">Обработчики.</a></h3>
<p>Рассмотрим ассемблерный файл cpu/vector.S, здесь мы с помощью макро языка создаем 256 обработчиков исключений, которые мы будем называть vector\i (можете дизассамблировать файл с помощью objdump и увидите 256 функций). Эти вектора кладутся в default_handlers.</p>
<p>Рассмотрим сами вектора. На 31-ой строчке мы можем увидеть if — он кладет 0 в стек для тех векторов, в которых не был положен процессором код ошибки (это нужно для того, чтобы у всех обработчиков стек выглядел однородно). Потом уже мы делаем push номера обработчика.</p>
<p><img src="interrupts/Interrupts%20ec9425c586194a9899990eff69a46822/Untitled%201.png" alt="Untitled" /></p>
<p>Далее мы прыгаем в функцию alltraps, которая является общим обработчиком прерываний и лежит в том же файле. </p>
<p><img src="interrupts/Interrupts%20ec9425c586194a9899990eff69a46822/Untitled%202.png" alt="Untitled" /></p>
<p>С 5-ой по 8-ую строчку мы сохраняем все сегментные регистры (регистр cs за нас уже сохранил процессор), а инструкцией pushal мы сохраняем все регистры общего назначения (чтобы потом их всех восстановить). Далее мы вызываем уже Си-шную функцию trap, определённую в cpu/idt.c.</p>
<p>trap — это функция, которая принимает на вход указатель на структуру registers_t, которая уже в свою очередь определена в cpu/isr.h и выглядит следующим образом. </p>
<p><img src="interrupts/Interrupts%20ec9425c586194a9899990eff69a46822/Untitled%203.png" alt="Untitled" /></p>
<p>Нетрудно догадаться, что она просто хранит в себе всю информацию о сохраненных в alltraps регистров. </p>
<p>И чтобы передать указатель на registers_t мы кладём в 15-ой строчке функции alltraps регистр esp, который как раз указывает на начало нашей структуры</p>
<p>.</p>
<p><img src="interrupts/Interrupts%20ec9425c586194a9899990eff69a46822/Untitled%204.png" alt="Untitled" /></p>
<p>Как видим — функция trap не слишком гостеприимна и сразу же нас встречает двумя if-ами с 89-ой по 94-ую строки. Объяснения такие: чтобы контролер прерываний передал следующее прерывание процессору — нужно ему сообщить, что предыдущее мы уже завершили. Поэтому мы должны сказать, что произошла ситуация EOI - end of interrupt, но поскольку контроллеров прерываний у нас два, то с 32-ого вектора по 40-ой мы сообщаем одному контроллеру, а с 40-ого уже двум. </p>
<p>Далее мы уже в 97-ой строчке проверяем, что существует обработчик прерываний для нашего прерывания, и если он есть, то просто запускаем его.</p>
<p>Если прерывание имеет номер до 32 (зарезервированные интелом номера), то мы просто вызываем функцию panic (заставляем ядро паниковать), предварительно напечатав сообщение об ошибке, которое мы взяли с соответствующей таблицы.</p>
<h3 id="Пора-возвращаться-домой"><a class="header" href="#Пора-возвращаться-домой">Пора возвращаться домой.</a></h3>
<p>После обработки исключения мы вернёмся обратно в функцию alltraps.</p>
<p><img src="interrupts/Interrupts%20ec9425c586194a9899990eff69a46822/Untitled%205.png" alt="Untitled" /></p>
<p>с 17-ой по 25-ую строчку мы восстановим все регистры, которые мы положили в стек (popal - противоположность pushal) а в 26-ой строчке убираем код ошибки и номер вектора со стека.
Далее вызываем iret, который восстанавливает cs, eip и eflags, тем самым мы возвращаемся в ту точку программы, на которой мы были прерваны для обработки прерывания.</p>
<h3 id="Разбор-обработчика-прерываний-для-клавиатуры"><a class="header" href="#Разбор-обработчика-прерываний-для-клавиатуры">Разбор обработчика прерываний для клавиатуры.</a></h3>
<p>Находится данный обработчик в файле driver/keyboard.c, загружаем мы его в таблицу обработчиков с помощью функции init_keyboard(), в которой вызывается register_interrupt_handler.</p>
<p><img src="interrupts/Interrupts%20ec9425c586194a9899990eff69a46822/Untitled%206.png" alt="Untitled" /></p>
<p>В 18-ой строчке из порта клавиатуры мы читаем scancode — номер клавиши и в верхних старших битах сообщение о состоянии нажатия клавиши.</p>
<p>Таблица сканкодов имеется в том же файлике:</p>
<p><img src="interrupts/Interrupts%20ec9425c586194a9899990eff69a46822/Untitled%207.png" alt="Untitled" /></p>
<p>А дальше просто очевидно обрабатываем scancode с таблицы и печатаем его на экран (25-ая строчка).</p>
<h3 id="Как-хендлеры-попадают-в-таблицу-обработчиков-процессора"><a class="header" href="#Как-хендлеры-попадают-в-таблицу-обработчиков-процессора">Как хендлеры попадают в таблицу обработчиков процессора?</a></h3>
<p>Это происходит благодаря функции load_idt (из cpu/idt), которая вызывается в _start (kernel.c). </p>
<p><img src="interrupts/Interrupts%20ec9425c586194a9899990eff69a46822/Untitled%208.png" alt="Untitled" /></p>
<p>Функция init_idt просто заполняет нашу таблицу — она берёт адрес вектора из default_handlers и кладёт в таблицу <strong>idt_gate_t idt[IDT_HANDLERS]</strong>. Далее в специальную структуру мы кладём адрес нашей таблицы и с помощью ассемблерной инструкции lidt мы загружаем нашу таблицу обработчиков в процессор.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Кольца-защиты"><a class="header" href="#Кольца-защиты">Кольца защиты</a></h1>
<p>Каждая программа запускается с некоторым уровнем привелегий (информация о котором хранится в младших 2 битах регистра cs процессора), который может быть повышен и исключительных ситуациях. Программы, являющиеся частью операционной системы запускаются с уровнем привилегий 0 (наивысшим), пользовательские программы (userspace), запускаются с уровнем привилегий 3.  Уровни привилегий 1 и 2 могут использоваться для исполнения драйверов внешних устройств (однако в современных ОС используются только кольца 0 и 3).</p>
<p><strong>Привилегии колец:</strong></p>
<p><strong>Ring 0:</strong></p>
<ul>
<li>Доступ к железу (port mapped IO, memory mapped IO)</li>
<li>Служебные регистры (<a href="https://wiki.osdev.org/CPU_Registers_x86#GDTR">GDTR, IDTR</a>, <a href="https://wiki.osdev.org/CPU_Registers_x86#Control_Registers">контрольные регистры</a>)</li>
<li>Служебные инструкции (lgdt, lidt, cli/sti, …)</li>
</ul>
<p><strong>Ring 3:</strong></p>
<ul>
<li>
<p>Доступ к инструкциям/регистрам общего назначения (полностью самостоятельно можно только пользоваться доступной памятью и что-то считать, за всем остальным придется звать ядро)</p>
<p>При исполнении кода из какого-либо сегмента, процессор смотрит в таблицу дескрипторов сегментов, и подгружает в cs номер дескриптора. Верхние 13 бит нового значения отвечают соответственно за этот самый номер в (GDT). В cs есть ещё 3 значащих бита(регистр 16-битный) - один бит локальности, по нему регистр понимает где смотреть дескрипторы, в локальной таблице дескрипторов (LDT), или в глобальной(GDT), и младшие 2 бита - TPL(Target privilege level). После загрузки номера дескриптора проверяется соответствие привилегий текущих и требуемых (CPL и TPR - current / target PL), и дескриптор загружается в кэш процессора.</p>
</li>
</ul>
<p><strong>Сегментация</strong></p>
<p>При запуске Яблока создаются 4 базовых сегмента:</p>
<pre><code class="language-c">#define USER 3
#define KERNEL 0
#define UBASE 0xffff0000

// SEG(EFLAGS, base, offset, privilege level) - запись сегмента в GDT

void init_seg_desc(void) {
	seg_desc[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, KERNEL) 
	seg_desc[SEG_KDATA] = SEG(STA_W,       0, 0xffffffff, KERNEL)
	seg_desc[SEG_UCODE] = SEG(STA_X|STA_R, UBASE, 0xffffffff - UBASE, USER)
	seg_desc[SEG_UDATA] = SEG(STA_W,       UBASE, 0xffffffff - UBASE, USER)

}

// соответственно, физический адрес памяти вычисляется следующим образом:
//  base + SEG_OFFSET
</code></pre>
<h3 id="Обработка-прерываний"><a class="header" href="#Обработка-прерываний">Обработка прерываний</a></h3>
<pre><code>При возникновении прерывания (аппаратного или программного), процессору надо повысить свой уровень привилегий, обработать прерывание, а после понизить его обратно. 
</code></pre>
<p>Псевдокод обработки прерывания:</p>
<pre><code class="language-c">vector X; ←- наш вектор прерываний
gate = idt[X]; &lt;-- берём gate из таблицы прерываний по этому вектору
selector = gate.selector;
dpl = selector.pl; &lt;-- уровень привилегий на котором должен быть обработан X

if cpl &gt; dpl { // cpl - current privilege level
	switch_stack();
	change_privilege_level();
}

// обработка прерывания
</code></pre>
<p><strong>Псевдо-реализация переключения стеков процессов:</strong> </p>
<ul>
<li>Сохраняем состояние программы (регистры) в стек</li>
<li>Кладем в %esp верх другого стека</li>
<li>С нового стека снимаем состояние программы (регистры) и продолжаем исполняться</li>
</ul>
<h3 id="Обработка-прерываний-в-Яблоке"><a class="header" href="#Обработка-прерываний-в-Яблоке">Обработка прерываний в Яблоке:</a></h3>
<pre><code class="language-c">void trap(registers_t *r) {
	if(r-&gt;int_no == T_SYSCALL) { // отдельная проверка на системный вызов - частый частный случай прерывания
		switch(r-&gt;eax) {
		
		case SYS_exit:
			if(r-&gt;ebx) {
				kprinf(&quot;Success\n&quot;);
			} else { 
				kprintf(&quot;Program finished with exit code %d\n&quot;, r-&gt;ebx);
			}
			killproc(); // переключение стека без сохранения текущего состояния

		case SYS_greet:
			kprintf(&quot;Hello world!\n&quot;);
			r-&gt;eax = 0;
			break;
		
		default:
			kprinf(&quot;Unknown syscall);
			r-&gt;eax = -1;
			break;
		}
	}
}
</code></pre>
<h3 id="Системный-вызов"><a class="header" href="#Системный-вызов">Системный вызов</a></h3>
<p>инструкция int $0x84(Yabloko-specific, int $0x80 для Linux/i368) - обычное прерывание</p>
<p>%eax ← function</p>
<p>%ebx ← arg1</p>
<p>%ecx ← arg2</p>
<p>%edx ←arg3</p>
<pre><code>Например, инструкция int $0x80 (системное прерывание 128), может вывести на экран строку, для этого в %eax должен быть номер функции (4 в данном случае), в	
%ebx - файловый дескриптор (лучше перед вызовом проверить его валидность), в %ecx - адрес массива (не обязательно типа char), в %edx - sizeof() выводимого буффера.
</code></pre>
<pre><code class="language-c">// пример как может быть реализован тот же системный вызов write(...)
void print_string(int fd, char* str, int32_t length) {
	asm volatile(
		&quot;mov $4, %eax \n&quot;
		&quot;int $0x80 \n&quot;
		:
		: &quot;b&quot;(fd), &quot;c&quot;(str), &quot;d&quot;(length)
		: &quot;eax&quot; // indeed nessesary clobber
		);
}
</code></pre>
<h3 id="Виртуальная-память"><a class="header" href="#Виртуальная-память">Виртуальная память</a></h3>
<p>Страничная виртуальная память - отображение каждого “блока” памяти определенного размера на физическую память внутри процессора</p>
<p><img src="15-rings/screenshot.png" alt="Screenshot 2023-02-05 193419.png" /></p>
<ul>
<li>У каждого процесса свое отображение</li>
<li>Стандартный размер страницы - 4KiB</li>
<li>Первые 10 бит адреса - индекс page directory</li>
<li>Вторые 10 бит - индекс в page table</li>
<li>Оставшиеся 12 бит - смещение внутри страницы памяти</li>
<li>Процессор может положить отображение в свой кэш(TLB - translation lookaside buffer) →  отображение 20-битного префикса адреса на физический адрес памяти. Сбрасывается после переключения процесса</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Операционная-система-1"><a class="header" href="#Операционная-система-1">Операционная система</a></h2>
<p>ПО, которое организует доступ к ресурсам компьютера:</p>
<ul>
<li>унифицирует (драйверы, файловая система, ...);</li>
<li>разделяет (вытесняющая многозадачность, виртуальная память, ...);</li>
<li>разграничивает (права доступа для пользователей, ...).</li>
</ul>
<p>Чтобы ОС могла выполнять свои функции, нужна поддержка
со стороны процессора: привилегированный режим,
в котором будет исполняться часть ОС, называемая
<em>ядром</em> (kernel).</p>
<pre><code> Прикладные программы

 Системные утилиты

                                       Userspace
────────────────────────────────────────────────────────
                                       Kernelspace
 Ядро ОС                              (привилегированный
                                       режим)
</code></pre>
<h2 id="Переносимость-и-совместимость"><a class="header" href="#Переносимость-и-совместимость">Переносимость и совместимость</a></h2>
<p>API (application programming interface) — контракт на уровне
исходного кода (source-level).</p>
<p>Пример — API стандартной библиотеки языка Си.</p>
<p>ABI (application binary interface) — контракт на уровне
машинного кода и двоичного представления данных:
соглашения о вызовах, способы компоновки,
порядок загрузки и запуска программы,
интерфейс взаимодействия с ядром ОС.
Нас будет особенно интересовать ABI Linux/x86.</p>
<h2 id="Семейство-юниксовых"><a class="header" href="#Семейство-юниксовых">Семейство юниксовых</a></h2>
<p>Картинка из Википедии:
<img src="../../upload.wikimedia.org/wikipedia/commons/c/cd/Unix_timeline.en.svg" alt="" /></p>
<p>В 70-х Кен Tомпсон и Деннис Ричи разработали ОС Research UNIX. В 80-е AT&amp;T ее
коммерциализировала. В это же время Ричард Столлман придумал проект GNU, для
него не хватало ядра. В 90-е Линус Торвальс начал разрабатывать Linux, проект
GNU его подхватил. Теперь мы пользуемся ОС GNU/Linux, название означает OC GNU и
ядро Linux.</p>
<p>Все это развивалось в разных направлениях, переносить программы между разными юниксами было тяжело, были попытки обеспечить переносимость программ между разными юниксами.</p>
<p>В 1985 году компания AT&amp;T специфицировала UNIX System V в документе
<a href="https://en.wikipedia.org/wiki/System_V_Interface_Definition">System V Interface Definition (SVID)</a>.</p>
<p>В 1988 рабочая группа IEEE выпустила первый стандарт POSIX (portable operating system interface), который стандартизировал, что такое UNIX.</p>
<p><a href="https://xkcd.com/927/">xkcd: How standards proliferate</a></p>
<p>1994, X/Open: Single UNIX Specification (SUS).</p>
<h2 id="Системные-вызовы-на-linuxx86"><a class="header" href="#Системные-вызовы-на-linuxx86">Системные вызовы на Linux/x86</a></h2>
<p>Осуществляются (пока что магической) инструкцией <code>int $0x80</code>.
В регистре <code>eax</code> должен быть номер системного вызова,
а в регистрах <code>ebx</code>, <code>ecx</code> и <code>edx</code> — его аргументы по порядку.</p>
<p>Результат системного вызова возвращается в регистре <code>eax</code>.</p>
<p>Напишем программу <code>bare.S</code>, которая делает системный вызов <code>exit</code>,
не пользуясь стандартной библиотекой языка Си:</p>
<pre><code>#include &lt;sys/syscall.h&gt;

    .global _start
_start:                  // default ELF entry point
    mov $SYS_exit, %eax  // SYS_exit == 1
    mov $42, %ebx        // exit(int status) ← status = 42
    int $0x80
</code></pre>
<p>Соберём её:</p>
<pre><code>gcc -m32 -static -nostdlib bare.S -o bare
</code></pre>
<p>То же самое в виде программы на языке Си:</p>
<pre><code>#include &lt;sys/syscall.h&gt;

void _start() {
    asm volatile (&quot;int $0x80&quot; : : &quot;a&quot;(SYS_exit), &quot;b&quot;(42));
}
</code></pre>
<p>Системные вызовы документированы в секции 2 руководства
(<strong>man</strong>ual), поэтому почитать документацию на системный вызов
exit можно так: <code>man 2 exit</code>.</p>
<h2 id="Файлы"><a class="header" href="#Файлы">Файлы</a></h2>
<p>Главная сущность, которую мы будем изучать - файлы, поскольку в unix-подобных
системах почти все ресурсы представлены именно через эту абстракцию.</p>
<p>Файл — последовательность байт, к которой ОС предоставляет
доступ посредством <em>файловых операций</em>.</p>
<p>Например:</p>
<ul>
<li>файл на диске;</li>
<li>вывод программы;</li>
<li>пользовательский ввод;</li>
<li>бесконечная последовательность случайных байт;</li>
<li>всё содержимое диска;</li>
<li>...</li>
</ul>
<pre><code>    ───────────────────────────
... Mary had a little lamb, its ...
    ───────────────────────────
          ▲
          │ file position

read(1) → &quot;a&quot;
read(5) → &quot;d a l&quot;
read(5) → &quot;ittle&quot;
write(5, &quot; wolf&quot;)

    ───────────────────────────
... Mary had a little wolf, its ...
    ───────────────────────────
                          ▲
                          │

lseek(-3, SEEK_CUR)  // move file position 3 bytes to the left

    ───────────────────────────
... Mary had a little wolf, its ...
    ───────────────────────────
                       ▲
                       │
</code></pre>
<p>Заметим, что системные вызовы write/read/lseek могут не иметь смысла при работе с
конкретным файлом. Например, в файл “пользовательский ввод” нельзя ничего
записать или подвинуть позицию чтения/записи.</p>
<p>Конец файла (EOF):</p>
<pre><code>    ─────────────────────────┐
... il sole e l'altre stelle.│
    ─────────────────────────┘
                      ▲
                      │

read(10) → &quot;stelle.&quot;
read(10) → &quot;&quot;
write(5, &quot; FIN.&quot;)

    ──────────────────────────────┐
... il sole e l'altre stelle. FIN.│
    ──────────────────────────────┘
                                  ▲
                                  │
</code></pre>
<blockquote>
<p>Q. А как пользователь понимает, где EOF?</p>
<p>A. EOF - ситуация, она нигде. EOF (end of file) -  это не специальный символ, а ситуация, когда после запроса на считывание байтов считывается 0 байт.</p>
</blockquote>
<h2 id="Файловые-дескрипторы"><a class="header" href="#Файловые-дескрипторы">Файловые дескрипторы</a></h2>
<p>Операции для работы с файлами - это системные вызовы, то есть обращения к ядру.
Чтобы объяснить ядру, c каким из файлов мы хотим работать, нужны идентификаторы.
В качестве идентификаторов выступают файловые дескрипторы — целые числа.</p>
<pre><code>               char buf[10];
               int fd = 3;
               read(fd, buf, sizeof(buf));
Userspace
──────────────────────────────────────────
Kernelspace
               0 → keyboard
               1 → display
               2 → display
               3 → somefile.txt
</code></pre>
<ul>
<li>0 (<code>STDIN_FILENO</code>) — standard input</li>
<li>1 (<code>STDOUT_FILENO</code>) — standard output</li>
<li>2 (<code>STDERR_FILENO</code>) — standard error output </li>
</ul>
<blockquote>
<p>Q. Для разных процессов разные дескрипторы?</p>
<p>A. Да, у каждого процесса есть собственная таблица файловых дескрипторов.</p>
</blockquote>
<h2 id="posix-file-api"><a class="header" href="#posix-file-api">POSIX file API</a></h2>
<h3 id="Системные-вызовы-read-и-write"><a class="header" href="#Системные-вызовы-read-и-write">Системные вызовы read и write</a></h3>
<pre><code class="language-c">#include &lt;unistd.h&gt;

ssize_t read(int fd, void *buf, size_t count); // ssize_t - знаковый size_t, нужен, чтобы помещалось значение -1
ssize_t write(int fd, const void *buf, size_t count);
</code></pre>
<ul>
<li>если считывание прошло успешно, read возвращает количество считанных байт (0, если достигли конца файла)</li>
<li>если произошла ошибка, read возвращает -1, а также выставляет специальную переменную <code>errno</code>. В <code>errno</code> хранится номер последней произошедшей при системных вызовах ошибки</li>
</ul>
<p>Напишем программу mycat, которая будет читать байты со стандартного входа и
писать их на стандартный выход с помощью системных вызовов.</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;

int main() {
    char c; // наш буфер в один байт
    while (read(STDIN_FILENO, &amp;c, sizeof(c)) &gt; 0) { // STFIN_FILENO = 0
        write(STDOUT_FILENO, &amp;c, sizeof(c)); // STDOUT_FILENO = 1
    }
}
</code></pre>
<p>Чтобы сделать конец файла, нажмем ctrl + d. Так драйвер терминала порождает конец файла.</p>
<blockquote>
<p>Q. Получается, ядро считывает ввод до \n?</p>
<p>A. Да. Это можно поменять с помощью драйвера терминала.</p>
</blockquote>
<p>Команда strace показывает, какие системные вызовы совершает наша программа. Использовать вот так: <code>strace ./mycat</code></p>
<p>Наш буфер сейчас 1 байт. Если файл очень большой, то программа будет работать
долго, поскольку каждый системный вызов занимает некоторое время. Давайте
увеличим буфер, в который читаем файл.</p>
<blockquote>
<p>Q. Не получится ли плохая ситуация, когда в файле осталось читать только 100 байт, а мы просим 200?</p>
<p>A. Нет, когда мы просим считать больше байтов, чем осталось на чтение в файле, read считывает, сколько есть.</p>
</blockquote>
<h3 id="Системный-вызов-open"><a class="header" href="#Системный-вызов-open">Системный вызов <strong>open</strong></a></h3>
<pre><code class="language-c">int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
</code></pre>
<ul>
<li>Если файл удалось открыть, <code>open</code> возвращает файловый дескриптор</li>
<li>Если не удалось, <code>open</code> вернет -1, а также выставит номер ошибки в errno</li>
</ul>
<p>Заметим, что приведены две функции open с разными сигнатурами. Язык С так не умеет, на самом деле функция open принимает произвольное количество параметров.</p>
<p>Напишем программу, которая умеет работать с аргументами командной строки</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void catfile(int sourcefd) {
    char buf[10000];
    ssize_t result;
    while ((result = read(sourcefd, buf, sizeof(buf))) &gt; 0) {
        write(STDOUT_FILENO, buf, result);
    }
}

int main(int argc, char *argv[]) {
    if (argc == 1) {
        catfile(STDIN_FILENO);
    } else {
        for (int f = 1; f &lt; argc; ++f) {
            int fd = open(argv[f], O_RDONLY); // в argv[f] путь к файлу
            if (fd &lt; 0) {
                perror(&quot;error opening file&quot;); // print error, лежит в &lt;stdio.h&gt;. принимает строку, печтает ее и сообщение об ошибке, исходя из errno
                return EXIT_FAILURE;  // EXIT_FAILURE = 1
            }
            catfile(fd);
            close(fd);  // всего 1024 доступных файловых дескрипторов, хочется избежать, чтобы при каждом open давали новый файловый дескриптор
        }
    }
}
</code></pre>
<blockquote>
<p>Q. Функция <code>_start</code> тоже принимает на вход аргументы командной строки?</p>
<p>A. Да, но в стеке.</p>
</blockquote>
<h2 id="Флаги-1"><a class="header" href="#Флаги-1"><strong>Флаги</strong></a></h2>
<ul>
<li>Режима доступа к файлу: O_RDONLY, O_WRONLY и O_RDWR</li>
<li>O_TRUNC обрезает файл, при открытии он получит размер 0</li>
<li>O_CREAT создаст файл, если его нет</li>
<li>O_APPEND установит файловую позицию чтения/записи на конец файла</li>
</ul>
<h3 id="Системный-вызов-lseek"><a class="header" href="#Системный-вызов-lseek"><strong>Системный вызов lseek</strong></a></h3>
<pre><code class="language-c">off_t lseek(int fd, off_t offset, int whence);
</code></pre>
<p><em>offset</em> - на сколько байт перемотать относительно точки отсчета</p>
<p><em>whence</em> - точка отсчета:</p>
<ul>
<li><code>SEEK_SET</code> - с начала файла</li>
<li><code>SEEK_CUR</code> - с текущей позиции</li>
<li><code>SEEK_END</code> - с конца файла</li>
</ul>
<p>Напишем программу, которая перематывает файл на заданную позицию и там что-то записывает.</p>
<pre><code class="language-c">#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

const char usage[] = &quot;Usage: binpatch FILE OFFSET DATA\n&quot;;

int main(int argc, char *argv[]) {
    if (argc != 4) {
        write(STDERR_FILENO, usage, strlen(usage));
        return EXIT_FAILURE;
    }

    const char *name = argv[1];
    int offset = atoi(argv[2]);
    const char *data = argv[3];

    int fd = open(name, O_WRONLY | O_CREAT, S_IWUSR | S_IRUSR); // если передать название несуществующего файла, то благодаря O_CREAT он будет создан
    if (fd &lt; 0) {
        perror(name);
        return EXIT_FAILURE;
    }

    if (lseek(fd, offset, SEEK_SET) &lt; 0) {
        perror(&quot;seek&quot;);
        return EXIT_FAILURE;
    }
    
    if (write(fd, data, strlen(data)) &lt; 0) {
        perror(&quot;write&quot;);
        return EXIT_FAILURE;
    }

    off_t position = lseek(fd, 0, SEEK_CUR);  // lseek возвращает смещение от начала записи после исполнения
    ftruncate(fd, position);  // обрезает файл
    // можно не закрывать файл, поскольку мы выходим из программы, и ОС подчистит все наши файловые дескрипторы 
}
</code></pre>
<ul>
<li>Если в пустом файле сдвинуть позицию на 5 байт и записать туда 3 байта, то размер файла станет 8, первые 5 байт заполнятся нулями</li>
<li><code>/dev/stdin</code> для каждого процесса показывает его стандартный вход, в этом файле нельзя переставить позиции чтения и записи. Если передать этот файл в нашу программу, словим ошибку ESPIPE (illegal seek).</li>
</ul>
<h2 id="Переносимость-в-языке-си"><a class="header" href="#Переносимость-в-языке-си"><strong>Переносимость в языке си</strong></a></h2>
<p>Если мы хотим, чтобы наши программы были переносимы, то пользоваться вызовами, которые стандартизированы POSIX, нельзя. Поэтому язык С предоставляет стандартизированные способы работы с файлами.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

FILE *fopen(const char *pathname, const char *mode);
</code></pre>
<ul>
<li>при успехе возвращает указатель на структуру FILE</li>
<li>при ошибке возвращает NULL и выставляет номер ошибки в errno</li>
</ul>
<p>Заметим, что <code>mode</code> передаем как символьную строку, она может принимать следующие значения:</p>
<p><img src="16-files/images/image8.png" alt="image8" /></p>
<p>Перенос строки <code>\n</code> в UNIX-подобных ОС - это символ с кодом 10, а на Windows перевод строки - это символы CR и LF (коды 13 и 10). Ради переносимости язык C работает с текстовым файлами так, чтобы <code>\n</code> превращался в тот символ переноса, что нужен на конкретной платформе. Эту опцию можно отключить, добавив в конце <code>mode</code> букву b.</p>
<pre><code class="language-c">// другие функции библиотеки С для работы с файлами

int fclose(FILE *stream);
int fprintf(FILE *stream, const char *format, ...);
int fseek(FILE *stream, long offset, int whence);
</code></pre>
<p>Стандартная библиотека языка С создает потоки ввода/вывода буферизованными: данные накапливаются в буфере, пока он не заполнится. Только тогда данные передаются в системный вызов write.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt; 
#include &lt;unistd.h&gt;

int main() {
    FILE *f = fopen(&quot;poem. txt&quot;, &quot;w&quot;);
    fprintf(f, &quot;some string&quot;);
    fprintf(f, &quot; and some other string\n&quot;);
    pause();
    fclose(f);
}
</code></pre>
<p>Если во время выполнения <code>pause</code> убить программу, то в файл poem.txt ничего не запишется. Чтобы принудительно очистить буфер, нужно написать <code>fflush(f)</code> перед <code>pause</code>. Если убрать <code>pause</code> и не закрывать файл, то данные все равно окажутся на диске, т.к. когда завершается <code>main</code>, стандартная библиотека языка С вызывает функцию <code>exit</code>, которая закрывает все потоки ввода и вывода, очищая их буферы.</p>
<p>Но нам не всегда хочется при завершении программы закрывать потоки, поэтому можно самим вызвать системный вызов exit:</p>
<pre><code class="language-c">syscall(SYS_exit, EXIT_SUCCESS);
</code></pre>
<pre><code class="language-c">void _exit(int status); // функция в POSIX. завершает программу, но не сбрасывает буфер
void _Exit(int status); // аналогичная функция в стандартной библиотеке си
</code></pre>
<p>Бывают потоки, буферизованные построчно. Например, стандартные потоки ввода/вывода. При встрече <code>\n</code> они сбрасывают буфер. <code>stderr</code>, напротив, не буферизован, благодаря этому сообщения об ошибках появляются сразу.</p>
<pre><code class="language-c">void setbuf(FILE *stream, char *buf); // для управления буферизацией
void setlinebuf(FILE *stream); // для строчной буферизации
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Файловая-система"><a class="header" href="#Файловая-система">Файловая система</a></h1>
<h2 id="Права-доступа"><a class="header" href="#Права-доступа">Права доступа</a></h2>
<p>Linux - многопользовательская система, поэтому она организует разделение доступов для пользователей. Если набрать <code>ls -l</code> в терминале, то увидим файлы, а также пользователя, группу и права доступа для каждого файла.</p>
<p>Права доступа записываются в виде трех троек бит. Первая тройка обозначает, что
может делать с файлом владелец, вторая тройка - пользователь, входящий в группу,
третья тройка - все остальные. Буквы обозначают следующее: r - право читать, w -
записывать, x - исполнять как программы.</p>
<p><img src="17-file-system/images/image2.png" alt="image2" /></p>
<p>Режимы доступа можно задавать самим, когда файл создается. Мы делали это в нашей прошлой программе:</p>
<pre><code class="language-c">int fd = open(name, O_WRONLY | O_CREAT, S_IWUSR | S_IRUSR); // S_IWUSR и S_IRUSR - макросы на восьмеричные числа, которые обозначают биты защиты 
</code></pre>
<p><img src="17-file-system/images/image3.png" alt="image3" /></p>
<p>Посмотреть всех пользователей можно <code>less /etc/passwd</code> , а группы <code>less /etc/group</code>.</p>
<h3 id="Системный-вызов-stat"><a class="header" href="#Системный-вызов-stat"><strong>Системный вызов stat</strong></a></h3>
<pre><code class="language-c">int stat(const char *pathname, struct stat *statbuf); // stat - структура с информацией о файле
</code></pre>
<p><img src="17-file-system/images/image4.png" alt="image4" /></p>
<p>Введя в терминал <code>stat filename</code>, можем получить информацию о размере файла, количестве блоков в нем, размере одного блока, времени доступа и др.</p>
<p><img src="17-file-system/images/image5.png" alt="image5" /></p>
<h2 id="Разные-сущности-файлов"><a class="header" href="#Разные-сущности-файлов"><strong>Разные сущности файлов</strong></a></h2>
<ul>
<li>Обычные файлы - последовательности байт</li>
<li>Директории, в которых лежат другие файлы и директории</li>
<li>Символические ссылки</li>
<li>Жесткие ссылки</li>
<li>Каналы</li>
<li>Блочные устройства. Например, диск, куда можно писать блоками</li>
<li>Символьные устройства. Например, терминал, куда можно читать и писать по одному символу</li>
</ul>
<p><strong>Символическая ссылка</strong> — специальный файл, который содержит путь к другому файлу. Когда программа открывает символическую ссылку, она не показывает содержимое файла, а открывает файл с названием, которое там записано. Если переименуем файл, на который указывает ссылка, то символическая ссылка не будет никуда показывать. <code>ln -s poem.txt poem2.txt</code> создаст символическую ссылку:</p>
<p><img src="17-file-system/images/image6.png" alt="image6" /></p>
<p>Все файлы на диске имеют номера, записанные в Inode. <strong>Жесткая ссылка</strong> появляется, когда разные имена файлов указывают на один Inode. <code>ln mary.txt poem.txt</code> создаст жесткую ссылку. mary.txt укажет на тот же Inode, что и poem.txt, и любые изменения в одном файле приведут к изменениям в другом. Если удалить один из файлов, то второй файл останется.</p>
<p>На Inode есть reference counter, показывающий, сколько имен ссылаются на это содержимое. Когда reference counter = 0, ОС удаляет файл. Если открыть файл, то его reference counter на это время увеличится.</p>
<pre><code class="language-c">int stat(const char *file_name, struct stat *buf);
int lstat(const char *pathname, struct stat *statbuf);
int fstat(int fd, struct stat *statbuf); // Для работы с открытым файлом с помощью файлового дескриптора, а не пути
int unlink(const char *pathname); // Удаляет связь с Inode. Если pathname - последнее имя, которое указывало на Inode, то Inode удалится
</code></pre>
<p>Утилита <code>stat</code> дает нам информацию о типе файла. Если в <code>stat</code> передать имя символической ссылки, то вместо нее ОС подставит тот файл, на который указывает ссылка. Поэтому, чтобы узнать, является ли файл символической ссылкой, используем вызов <code>lstat</code>, который работает как <code>stat</code>, но передает информацию о самой символьной ссылке, не производя замену.</p>
<h2 id="Директории"><a class="header" href="#Директории"><strong>Директории</strong></a></h2>
<p>Познакомимся с системными вызовами для работы с директориями.</p>
<pre><code class="language-c">DIR *opendir(const char *name);
DIR *fdopendir(int fd);
struct dirent *readdir(DIR *dirp); // возвращает 0, если дошли до конца директории
</code></pre>
<p>В структуре dirent можно посмотреть inode number, имя, тип файла и др.</p>
<p><img src="17-file-system/images/image7.png" alt="image7" /></p>
<blockquote>
<p>Напишем программу myls, которая отображает содержимое некоторой директории</p>
</blockquote>
<pre><code class="language-c">#include &lt;dirent.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char *argv[]) {
    const char *dirname = argv[1];
    DIR *d = opendir(dirname);
    struct dirent *ent;
    while ((ent = readdir(d))) {
        char buf[4096];  // чтобы записывать длинное имя файла
        snprintf(buf, sizeof(buf), &quot;%s/%s&quot;, dirname, ent-&gt;d_name);
        printf(&quot;%s\n&quot;, buf);
    }
}
</code></pre>
<pre><code class="language-c">int link(const char *oldpath, const char *newpath); // делает ссылки
int symlink(const char *target, const char *linkpath); // делает символические ссылки
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Вещественные-числа"><a class="header" href="#Вещественные-числа">Вещественные числа</a></h1>
<h2 id="Формат-представления-числа"><a class="header" href="#Формат-представления-числа">Формат представления числа</a></h2>
<p>Для хранения и обработки вещественных чисел большинство процессоров используют формат <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a>. Есть удобный <a href="https://www.h-schmidt.net/FloatConverter/IEEE754.html">калькулятор</a>.
Рассмотрим, как устроен формат, на примере 32-битных вещественных чисел: <img src="18-floating-point-arithmetic/float_example.png" alt="Float example" /></p>
<p>Биты числа разделены на 3 группы:</p>
<ol>
<li><strong>Знаковый бит</strong>. Один, старший бит. 0 -- число положительное, 1 -- отрицательное.</li>
<li><strong>Показатель степени</strong>. 8-битное целое число, занимает биты с 23-го по 30-ый. Означает <em>степень двойки</em>, на которую будет домножаться основаная часть числа, записанная далее.</li>
<li><strong>Дробная часть</strong>. 23-битное целое число, содержащее <em>значащие биты</em> вещественного числа.</li>
</ol>
<p>Обозначим знаковый бит как <code>sign</code>, беззнаковое значение показателя степени как <code>exp</code>,
а беззнаковое значение дробной части как <code>frac</code>.</p>
<h2 id="Значение-числа-в-разных-случаях"><a class="header" href="#Значение-числа-в-разных-случаях">Значение числа в разных случаях</a></h2>
<p>Итак, как числа получаются с помощью этих компонент? Есть несколько случаев:</p>
<ul>
<li>Если 1 &lt;= <code>exp</code> &lt;= 254, число называется <strong>нормализованным</strong>. В таком случае
оно равно \( -1^{sign} × 2^{exp-127} × 1,frac \).
То есть знак и степень двойки домножаются на число, у которого в целой части
стоит 1, а дробную часть состаляют 23 бита дробной части :-).</li>
</ul>
<p>Т.к. мы хотим представлять как большие по модулю числа, так и близкие к нулю, то
степень двойки должна принимать как положительные, так и отрицательные значения.
Поэтому мы вычитаем из неё 127 (смещение), так степень станет принимать значения
[-126; 127] (почему не могут быть -127 и 128, увидим ниже).</p>
<p><img src="18-floating-point-arithmetic/normalized_example.png" alt="Пример нормализованного числа" /></p>
<ul>
<li>Если exp=0, число называется <strong>денормализованным</strong>. В этом случае оно равно
\( -1^{sign} × 2^{-126} × 0,frac \).</li>
</ul>
<p><img src="18-floating-point-arithmetic/denormalized_example.png" alt="Пример денормализованного числа" /></p>
<p>Нормализованные и денормализованные числа отличаются тем, что в первых перед
мантиссой ставится целая часть 1, а во вторых -- 0. Это сделано для того, чтобы
уметь представлять <em>ноль</em>. Если бы перед мантиссой всегда ставилась 1, то <em>ноль</em>
бы не получался.</p>
<ul>
<li>Если <code>exp</code>=255 и <code>frac</code>=0, число называется <strong>бесконечностью</strong> и обозначается <code>+inf</code> или <code>-inf</code> в зависимости от знака.</li>
</ul>
<p><img src="18-floating-point-arithmetic/-inf_example.png" alt="Пример бесконечности" /></p>
<p>Бесконечности нужны для обозначения очень больших по модулю чисел, для представления которых не достаточно 8-ми бит показателя степени.</p>
<ul>
<li>Если <code>exp</code>=255 и <code>frac</code>!=0, число называется <strong>нечислом</strong> и обозначается &quot;NaN&quot;.  Знак при этом ни на что не влияет.</li>
</ul>
<p><img src="18-floating-point-arithmetic/nan_example.png" alt="Пример нечисла" /></p>
<p>Как видно, различных NaN-ов бывает много. Все они нужны для обозначения неопределённости в результате выполнения арифметических операций, например, 6/0 или sqrt(-3).</p>
<p>Итого, числовая прямая выглядит так: <img src="18-floating-point-arithmetic/visualization_encodings.png" alt="Визуализация числовой прямой" /></p>
<h2 id="Особенности-формата"><a class="header" href="#Особенности-формата">Особенности формата</a></h2>
<ul>
<li>
<p><strong>Есть два нуля</strong>: +0 и -0. Однако это не приносит проблем при взаимодействии других чисел с ними. Оба нуля являются денормализованными.</p>
</li>
<li>
<p>+0 имеет все нулевые биты, то есть является нулём как 32-битное целое число.</p>
</li>
<li>
<p><strong>Сравнение</strong>: наименьшее положительное нормализованное число
(\( 2^{-126} * 1,0\)) больше наибольшего денормализованного числа
(\( 2^{-126} * 0,111..1\)).
Также любое положительное нормализованное число с меньшим <code>exp</code>
меньше любого положительного нормализованного числа с большим <code>exp</code>. Таким
образом, действительно, все положительные денормализованные числа меньше всех
положительных нормализованных, а нормализованные расположены в порядке
показателя степени.</p>
</li>
<li>
<p>Такой же <strong>порядок остаётся, если сравнивать</strong> битовые представления вещественных чисел <strong>как знаковые целые числа</strong>! (Кроме NaN-ов).</p>
</li>
<li>
<p>Вещественные числа <strong>становятся более разреженными при увеличении</strong> их модуля. Чем число ближе к нулю, тем оно ближе к ближайшему к нему другому представимому числу. А точнее, денормализованные числа идут через одинаковый шаг. Нормализованные числа с <code>exp</code>=1 идут через удвоенный шаг, с <code>exp</code>=2 -- через учетверённый, и так далее. Иллюстрация распределения чисел: <img src="18-floating-point-arithmetic/visualization_disribution.png" alt="Иллюстрация распределения" /></p>
</li>
</ul>
<h2 id="Арифметические-операции"><a class="header" href="#Арифметические-операции">Арифметические операции</a></h2>
<ul>
<li><strong>Умножение</strong> числа на <strong>степень двойки</strong>. Достаточно прибавить/вычесть из показателя степени. При этом может получиться бесконечность.</li>
<li><strong>Умножение</strong> двух чисел. Достаточно <strong>сложить их показатели степени и перемножить мантиссы</strong>.
При этом в мантиссе может также получиться число &gt;= 2, тогда надо его нормализовать и прибавить 1 к показателю степени.
<strong>Если мантисса</strong> результата не влезает в <code>23</code> бита, её <strong>надо округлить</strong>. Если хвост &lt; 1/2 или &gt; 1/2, то округляется вниз или вверх, соответственно. Если хвост в точности 1/2, то округлять всегда в одну сторону плохо, т.к. при большом количестве последовательных операций может накопиться существенная погрешность. Поэтому в этом случае округляется к ближайшему чётному (то есть, если предыдущий бит равен 0, то вниз, если 1 -- вверх). Пример:</li>
</ul>
<pre><code>  |23 бита|           |23 бита|
1,01.....1101111 -&gt; 1,01.....11   // хвост &lt; 1/2, округляем вниз
  |       |           |       |
1,01.....0110011 -&gt; 1,01.....10   // хвост &gt; 1/2, округляем вверх
  |       |           |       |
1,01.....0010000 -&gt; 1,01.....00   // хвост = 1/2, округляем вниз
  |       |           |       |
1,01.....0110000 -&gt; 1,01.....10   // хвост = 1/2, округляем вверх
</code></pre>
<ul>
<li><strong>Деление</strong> аналогично.</li>
<li><strong>Сложение и вычитание</strong>. Привести оба числа к одинаковому показателю степени, выполнить операцию, привести к нормализованному или денормализованному виду и округлить по правилам выше, если потребуется.</li>
</ul>
<h2 id="Свойства-арифметических-операций"><a class="header" href="#Свойства-арифметических-операций">Свойства арифметических операций</a></h2>
<ul>
<li>При корректных арифметических операциях получается либо число, либо бесконечность.</li>
<li>Сложение и умножение коммутативны</li>
<li>Ассоциативности нет. Из-за округления в процессе выполнения операций могут получиться разные результаты. Например,
\((3.14 + 2^{100}) - 2^{100} = 0\), но
\(3.14 + (2^{100} - 2^{100}) = 3.14\).
Из-за этого, для сохранения точности выполнять операции стоит в определённом порядке. Например, если хотим сложить массив вещественных чисел в одно число, лучше всего делать это в порядке сортировки чисел по возрастанию модулей.</li>
<li>У конечных чисел есть обратный элемент по сложению.</li>
<li>Монотонность: \(a\geq b \implies a+c\geq b + c\), если нет переполнений и NaN-ов.</li>
</ul>
<h2 id="Вещественные-числа-в-c"><a class="header" href="#Вещественные-числа-в-c">Вещественные числа в C</a></h2>
<h3 id="Типы-и-их-особенности-в-c"><a class="header" href="#Типы-и-их-особенности-в-c">Типы и их особенности в C</a></h3>
<p>В C есть типы <em>float</em>, <em>double</em> и <em>long double</em>. На нашей системе они имеют размер 4, 8 и 12 байт соответственно. В 64-битном формате <code>exp</code> занимает 11 бит, а <code>frac</code> -- 52. Некоторые гарантии на арифметику:</p>
<ul>
<li>f = -(-f) -- верно всегда.</li>
<li>(d &lt; 0) =&gt; (2d &lt; 0) -- верно всегда, в том числе если получается <code>-inf</code>.</li>
<li>(d &gt; f) =&gt; (-f &lt; -d) -- верно всегда</li>
<li>d * d &gt;= 0 -- верно всегда</li>
</ul>
<p>Считая, что <em>int</em> также 32-битный, рассмотрим приведения типов:</p>
<ul>
<li>float -&gt; double: преобразутеся точно.</li>
<li>double -&gt; float: может потеряться точность или стать inf (если был большой по модулю показатель степени).</li>
<li>int -&gt; double: преобразуется точно, поскольку влезает в мантиссу.</li>
<li>int -&gt; float: будет округлён, если int большой по модулю и есть маленькие биты (не влезает в мантиссу).</li>
<li>float/double -&gt; int: дробная часть будет отброшена. Не определено, если целая часть не влезает в int.</li>
</ul>
<h3 id="Работа-с-вещественными-числами-в-c"><a class="header" href="#Работа-с-вещественными-числами-в-c">Работа с вещественными числами в C</a></h3>
<p>Для наглядности далее будет полезно запускать такой код. Он выводит все части числа в удобном формате:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

#define CHECK(exp) printf(#exp &quot; == %d\n&quot;, (exp))

int main() {
	union {
		float f;
		unsigned u;
	} uf;
	while (scanf(&quot;%f&quot;, &amp;uf.f) == 1) {
		printf(&quot;f (%%e) = %e\n&quot;, uf.f);
		printf(&quot;f (%%f) = %f\n&quot;, uf.f);
		printf(&quot;f (%%g) = %g\n&quot;, uf.f);
		printf(&quot;f (%%a) = %a\n&quot;, uf.f);
		printf(&quot;u = %x\n&quot;, uf.u);
		printf(&quot;sign = %u\n&quot;, uf.u &gt;&gt; 31);
		printf(&quot;exp = %u\n&quot;, (uf.u &gt;&gt; 23) &amp; 0xff);
		printf(&quot;frac = %x\n&quot;, uf.u &amp; 0x7fffff);
		CHECK(fpclassify(uf.f));
		CHECK(isnan(uf.f));
		CHECK(isfinite(uf.f));
		CHECK(isinf(uf.f));
		CHECK(isnormal(uf.f));
	}
}
</code></pre>
<p>Спецификаторы printf:</p>
<ul>
<li><code>%f</code>, <code>%e</code>, <code>%g</code> -- float/double в 10-ой системе счисления.</li>
<li><code>%a</code> -- float/double в 16-ой СС. Мантисса и показатель степени (c учётом смещения) разделаются символом <code>p</code>.
Например, <code>4.375</code> = <code>0x1.18p+2</code>.</li>
</ul>
<p>Функции для работы с вещественными числами:</p>
<ul>
<li><code>int fpclassify(float/double)</code> -- возвращает класс числа, то есть одно из следующих значений: <code>FP_NAN</code>, <code>FP_INFINITE</code>, <code>FP_ZERO</code>, <code>FP_SUBNORMAL</code>, <code>FP_NORMAL</code>.</li>
<li><code>int isnan(float/double)</code> -- является ли число NaN.</li>
<li><code>int isfinite(float/double)</code> -- является ли число не NaN и не бесконечностью.</li>
<li><code>int isinf(float/double)</code> -- 1, если +inf, -1, если -inf.</li>
<li><code>int isnormal(float/double)</code> -- является ли число нормализованным.</li>
</ul>
<p>Чтобы использовать функции из <code>math.h</code>, необходимо компилировать программу с флагом <code>-lm</code>.</p>
<h2 id="Инструкции-для-работы-с-вещественными-числами"><a class="header" href="#Инструкции-для-работы-с-вещественными-числами">Инструкции для работы с вещественными числами</a></h2>
<p>У процессора есть отдельные регистры для обработки нескольких значений за одну инструкцию и, соответственно, отдельные инструкции для работы с этими регистрами.
Есть 128-битные регистры XMM0-XMM31. В них можно поместить, например, 2 double, 4 float, 4 int, 8 short и т.д. Также есть 256-битные регистры YMM0-YMM31, являющиеся расширениями соответствующих XMM (по аналогии с AX-&gt;RAX). Аналогично, есть их 512-битные расширения, называемые ZMM0-ZMM31.</p>
<p>Эти регистры исторически добавлялись в следующем порядке: XMM-&gt;YMM-&gt;ZMM. Инструкции для работы с YMM называются SSE, а для работы с ZMM -- AVX. Мы на курсе будем работать только с SSE.</p>
<p>SSE инструкции:</p>
<ul>
<li><code>MOVAPD xmm1/m128 xmm2</code> -- положить два double, записанные в xmm1 (или в памяти) в xmm2. Если переклыдавем из памяти, она должна быть выровнена на 16 байт.</li>
<li><code>MOVUPD xmm1/m128 xmm2</code> -- то же самое, только нет требования к выравниванию. Работает дольше.
К счастью, и gcc при входе в функцию стек выравнивает на 16 байт, и *alloc выделяет память, выровненную на 16 байт, поэтому всегда можем использовать <code>MOVAPD</code>.</li>
<li><code>ADDPD xmm1/m128 xmm2</code> -- прибавить два double из xmm1 или из памяти к xmm2 поэлементно.</li>
<li><code>MOVSS e*x/m32 xmm2</code> -- загружает в младшие 32 бита xmm2.</li>
<li><code>HADDPD xmm1/m128 xmm2</code> -- выполняет &quot;горизонтальное&quot; сложение в двух числах отдельно и записывает в результат эти результаты подряд: <img src="18-floating-point-arithmetic/haddpd_example.png" alt="HADDPD example" /></li>
</ul>
<p>Все регистры XMM caller-saved (не надо сохранять внутри функции).</p>
<h2 id="Как-gcc-компилирует-работу-с-вещественными-числами"><a class="header" href="#Как-gcc-компилирует-работу-с-вещественными-числами">Как gcc компилирует работу с вещественными числами.</a></h2>
<p>Посмотрим, как следующая программа выглядит при компиляции с разными оптимизациями:
<img src="18-floating-point-arithmetic/work_with_float_example.png" alt="C_float_example" /></p>
<ol>
<li>Компилируем эту программу gcc без флагов оптимизации и в 32-битном режиме. Поскольку на 32-битной архитектуре мы не можем гарантировать, что процессор поддерживает SSE, то компилятор генерирует инструкции из устаревшего набора x87 (для сопроцессора). Мы с таким работать не хотим, поэтому идём дальше.</li>
<li>Соберём без <code>-m32</code> (то есть для 64-битной архитектуры). Получились SSE-инструкции, но пока что работающие с float-ми по-одиночке. <img src="18-floating-point-arithmetic/64bit_build_O0.png" alt="64bit build O0" /></li>
<li>Соберём с O3 и <code>-mavx -ftree-vertorize</code>. Так мы скажем компилятору, что доступны инструкции AVX, и чтобы он векторизовал операции. Но он почему-то всё равно не векторизует :(</li>
</ol>
<p>Чтобы печатать float-ы через printf на 32-битной архитектуре, используются инструкции x87. А на 64-битной параметры типа float и double в printf передаются через регистры xmm. Подробнее не будем изучать.</p>
<h2 id="Алгоритм-Кэхэна"><a class="header" href="#Алгоритм-Кэхэна">Алгоритм Кэхэна</a></h2>
<p>Чтобы сложить много вещественных чисел более точно, можно использовать такой алгоритм, учитывающий ошибку округления:</p>
<pre><code class="language-kotlin">function KahanSum(input)
    var sum = 0.0                 // Prepare the accumulator.
    var c = 0.0                   // A running compensation for lost low-order bits.

    for i = 1 to input.length do  // The array input has elements indexed input[1] to input[input.length].
        var y = input[i] - c      // c is zero the first time around.
        var t = sum + y           // Alas, sum is big, y small, so low-order digits of y are lost.
        c = (t - sum) - y         // (t - sum) cancels the high-order part of y; subtracting y recovers negative (low part of y)
        sum = t                   // Algebraically, c should always be zero. Beware overly-aggressive optimizing compilers!
    next i                        // Next time around, the lost low part will be added to y in a fresh attempt.

    return sum
</code></pre>
<p>Идея в том, что отдельно считаются неточная сумма больших по модулю чисел (переменная <code>sum</code>) и компенсация для накопленной ошибки округления (переменная <code>c</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Вещественные-числа-на-x86"><a class="header" href="#Вещественные-числа-на-x86">Вещественные числа на x86</a></h1>
<h2 id="fpu-x87"><a class="header" href="#fpu-x87">FPU (x87)</a></h2>
<p><a href="https://www.club155.ru/x86internalreg-fpucommon">8 80-битных регистров (extended precision)</a></p>
<p><a href="https://www.felixcloutier.com/x86/fld">FLD — загрузить число из памяти в стек FPU</a></p>
<p><a href="https://www.felixcloutier.com/x86/fst:fstp">FST/FSTP — сохранить вершину стека FPU в память</a></p>
<p><a href="https://www.felixcloutier.com/x86/fadd:faddp:fiadd">Пример операции: FADD</a></p>
<h2 id="Регистры-sse"><a class="header" href="#Регистры-sse">Регистры SSE</a></h2>
<p>SSE (Streaming SIMD Extension) - набор инструкций, позволяющий выполнять несколько одинаковых
операций одновременно. Набор инструкций SSE продолжает расширяться.</p>
<p>Для хранения аргументов операций SSE используются регистры <code>xmm</code>. 32-битная система команд
x86 позволяет использовать 8 регистров <code>%xmm0 ... %xmm7</code>. 64-битная система команд x64 позволяет использовать
16 регистров <code>%xmm0 ... %xmm15</code>. Регистры xmm являются scratch-регистрами, то есть при вызове подпрограмм
сохранение значений не гарантируется (как с регистрами <code>%eax, %ecx, %edx</code>).</p>
<p>Регистры xmm имеют размер 128 бит и могут хранить 2 64-битных, 4 32-битных целых или вещественных значения,
а также 8 16-битных или 16 8-битных целых значения. Интерпретация битового содержимого регистров xmm
зависит от выполняемой инструкции.</p>
<p>В стандартном соглашении о вызовах x64 первые 8 параметров вещественных типов float или double передаются
на регистрах <code>%xmm0 ... %xmm7</code>, последующие аргументы передаются в стеке. Результат вещественного типа возвращается
в регистре <code>%xmm0</code>.</p>
<p>В стандартном соглашении о вызовах x32 аргументы вещественных типов передаются на стеке. Специального выравнивания
для double не требуется. Результат вещественного типа возвращается в регистре FPU %st(0). Даже если результат в %st(0)
не используется вызывающей программой, он должен быть удален из стека FPU. Если в коде x86 для вычислений используется
SSE, а подпрограмма должна вернуть значение вещественного типа, результат из SSE должен быть скопирован на верхушку
стека FPU.</p>
<p>Например, для копирования значения типа double на FPU может использоваться следующая последовательность операций:</p>
<pre><code>        sub     $8, %esp        // резервируем память
        movsd   %xmm0, (%esp)   // копируем значение double из %xmm0 в стек
        fldl    (%esp)          // загружаем из стека на %st(0)
        add     $8, %esp        // очищаем стек
</code></pre>
<h2 id="Скалярные-вычисления-на-регистрах-sse"><a class="header" href="#Скалярные-вычисления-на-регистрах-sse">Скалярные вычисления на регистрах SSE</a></h2>
<p>Регистры SSE можно использовать для обычных вычислений с плавающей точкой. Такие инструкции по терминологии
Intel называются скалярными. В этом случае в регистрах xmm будет использоваться только младшая часть: младшие 32 или 64 бита.</p>
<p>Для пересылки скалярных значений могут использоваться следующие инструкции:</p>
<pre><code>        movsd   SRC, DST        // пересылка между регистрами xmm и памятью значения double
        movss   SRC, DST        // пересылка значения типа float
</code></pre>
<p>Эти инструкции позволяют пересылать значение из регистра xmm в другой регистр xmm, а также между регистрами xmm и памятью.
При обращении к памяти на x86 достаточно, чтобы значение double было выровнено по адресу, кратному 4.</p>
<p>Со скалярными значениями поддерживаются следующие операции:</p>
<pre><code>        addsd   SRC, DST        // DST += SRC, double
        addss   SRC, DST        // DST += SRC, float
        subsd   SRC, DST        // DST -= SRC, double
        subss   SRC, DST        // DST -= SRC, float
        mulsd   SRC, DST        // DST *= SRC, double
        mulss   SRC, DST        // DST *= SRC, float
        divsd   SRC, DST        // DST /= SRC, double
        divss   SRC, DST        // DST /= SRC, float
        sqrtsd  SRC, DST        // DST = sqrt(SRC), double
        sqrtss  SRC, DST        // DST = sqrt(SRC), float
        maxsd   SRC, DST        // DST = max(SRC, DST), double
        maxss   SRC, DST        // DST = max(SRC, DST), float
        minsd   SRC, DST        // DST = min(SRC, DST), double
        minss   SRC, DST        // DST = min(SRC, DST), float
</code></pre>
<p>Преобразование double-&gt;int выполняется инструкцией</p>
<pre><code>        cvtsd2si SRC, DST       // DST = (int32_t) SRC
</code></pre>
<p>Здесь SRC - регистр xmm или память, DST - 32-битный регистр общего назначения.
Инструкция выполняет преобразование вещественног числа типа double в 32-битное знаковое целое число.</p>
<p>Преобразование double-&gt;float выполняется инструкцией:</p>
<pre><code>        cvtsd2ss SRC, DST       // DST = (float) SRC
</code></pre>
<p>Преобразование int-&gt;double выполняется инструкцией:</p>
<pre><code>        cvtsi2sd SRC, DST       // DST должен быть регистр xmm, SRC либо GPR, либо память
</code></pre>
<p>Преобразование float-&gt;double:</p>
<pre><code>        cvtss2sd SRC, DST       // DST = (double) SRC
</code></pre>
<p>Для преобразований float-&gt;int и int-&gt;float предназначены инструкции cvtss2si и cvtsi2ss.</p>
<p>Сравнение двух скалярных значений типа float или double выполняется инструкцией:</p>
<pre><code>        comisd  SRC, DST        // DST - SRC, double
        comiss  SRC, DST        // DST - SRC, float
</code></pre>
<p>В результате выполнения операции сравнения устанавливаются флаги PF, CF, ZF. Флаг PF устанавливается,
если результат - неупорядочен. Флаг ZF устанавливается, если значения равны.
Флаг CF устанавливается, если DST &lt; SRC. Для условного перехода после сравнения можно
использовать условные переходы для беззнаковых чисел. Например, ja будет выполнять условный переход,
если DST &gt; SRC.</p>
<h2 id="Векторные-вычисления-на-регистрах-sse"><a class="header" href="#Векторные-вычисления-на-регистрах-sse">Векторные вычисления на регистрах SSE</a></h2>
<p>Векторные вычисления в терминологии Intel описываются как вычисления с упакованными (packed) значениями.</p>
<p>Для пересылки 128-битных значений между памятью и регистрами xmm и между двумя регистрами xmm
используется инструкция</p>
<pre><code>        movapd  SRC, DST        // DST = SRC
</code></pre>
<p>если один из аргументов - память, адрес должен быть выровнен по адресу, кратному 16.
Для пересылки по невыровненным адресам можно использовать инструкцию movupd.</p>
<p>С векторными значениями поддерживаются следующие операции, которые выполняются одновременно со всеми значениями
в регистрах (2 для double или 4 для float):</p>
<pre><code>        addpd   SRC, DST        // DST += SRC, double
        addps   SRC, DST        // DST += SRC, float
        subpd   SRC, DST        // DST -= SRC, double
        subps   SRC, DST        // DST -= SRC, float
        mulpd   SRC, DST        // DST *= SRC, double
        mulps   SRC, DST        // DST *= SRC, float
        divpd   SRC, DST        // DST /= SRC, double
        divps   SRC, DST        // DST /= SRC, float
        sqrtpd  SRC, DST        // DST = sqrt(SRC), double
        sqrtps  SRC, DST        // DST = sqrt(SRC), float
        maxpd   SRC, DST        // DST = max(SRC, DST), double
        maxps   SRC, DST        // DST = max(SRC, DST), float
        minpd   SRC, DST        // DST = min(SRC, DST), double
        minps   SRC, DST        // DST = min(SRC, DST), float
</code></pre>
<h2 id="Горизонтальные-операции"><a class="header" href="#Горизонтальные-операции">Горизонтальные операции</a></h2>
<p>Обычная операция над упакованными SSE-регистрами может рассматриваться как &quot;вертикальная&quot;. Например,
рассмотрим инструкцию <code>ADDPS A, B</code>. Эта инструкция складывает четыре float-значения в операнде A
с соответствующими 4 значениями в операнде B и кладет результат в операнд B. Если A и B рассматривать
как массивы из 4 значений типа float, то операция может быть описана следующим образом:</p>
<pre><code>    float A[4];
    float B[4];

    B[0] = A[0] + B[0]
    B[1] = A[1] + B[1]
    B[2] = A[2] + B[2]
    B[3] = A[3] + B[3]
</code></pre>
<p>В противовес &quot;вертикальной&quot; операции &quot;горизонтальная&quot; операция вовлекает соседние значение в одном регистре.
Например, инструкция <code>HADDPS A, B</code> выполняется следующим образом:</p>
<pre><code>    float A[4];
    float B[4];

    B[0] = B[0] + B[1];
    B[1] = B[2] + B[3];
    B[2] = A[0] + A[1];
    B[3] = A[2] + A[3];
</code></pre>
<h2 id="avx"><a class="header" href="#avx">AVX</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions">AVX</a></p>
<p><a href="https://habr.com/ru/companies/intel/articles/266055/">Применение масок</a></p>
<p><a href="https://branchfree.org/2019/02/25/paper-parsing-gigabytes-of-json-per-second/">SIMDJSON</a></p>
<h2 id="Обработка-ошибок"><a class="header" href="#Обработка-ошибок">Обработка ошибок</a></h2>
<p><a href="https://en.cppreference.com/w/c/numeric/fenv">Floating point environment</a></p>
<p><a href="https://berthub.eu/articles/posts/always-do-this-floating-point/">Always use feenableexcept</a></p>
<h2 id="Оптимизация"><a class="header" href="#Оптимизация">Оптимизация</a></h2>
<p><a href="https://kristerw.github.io/2021/10/19/fast-math/">Опция <code>-ffast-math</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="Сети-и-сокеты"><a class="header" href="#Сети-и-сокеты">Сети и сокеты</a></h2>
<p>Для обмена информацией в компьютерных сетях придуманы стандартные <em>протоколы</em>
(договорённости о том, кто когда что кому отправляет и что это значит).</p>
<h3 id="isoosi"><a class="header" href="#isoosi">ISO/OSI</a></h3>
<p><a href="https://en.wikipedia.org/wiki/OSI_model">Википедия</a></p>
<p>Protocol data unit (PDU)</p>
<ul>
<li>Physical</li>
<li>Data Link</li>
<li>Network</li>
<li>Transport</li>
<li>Session</li>
<li>Presentation</li>
<li>Application</li>
</ul>
<h3 id="tcpip"><a class="header" href="#tcpip">TCP/IP</a></h3>
<p><a href="https://en.wikipedia.org/wiki/Internet_protocol_suite">Стек протоколов Интернета</a>,
или стек TCP/IP, выглядит примерно так:</p>
<div class="table-wrapper"><table><thead><tr><th>Уровень</th><th>Протоколы этого уровня</th></tr></thead><tbody>
<tr><td>Прикладной (application)</td><td>HTTP, SSH, DNS, ...</td></tr>
<tr><td>Транспортный (transport)</td><td>TCP, UDP, SCTP, QUIC, ...</td></tr>
<tr><td>Межсетевой (inter-net)</td><td>IPv4, IPv6</td></tr>
<tr><td>Канальный (link)</td><td>Ethernet, Wi-Fi (IEEE 802.11), ...</td></tr>
</tbody></table>
</div>
<p>Обычно мы используем набор протоколов разных уровней, чтобы решить свою прикладную задачу. Например, при загрузке веб-страницы <a href="http://wiki.cs.hse.ru/">http://wiki.cs.hse.ru/</a> будут как минимум использоваться HTTP, TCP, IPv4 и какие-то канальные протоколы.</p>
<p>Фрагмент данных с верхнего уровня стека заворачивается в “конверт” нижнего уровня (картинка из википедии на примере UDP):</p>
<p><img src="22-sockets/sockets/Untitled.png" alt="Untitled" /></p>
<p>Данные доходят до адресата через цепочку промежуточных устройств, каждое из которых распаковывает и просматривает столько конвертов, сколько ему нужно и сколько оно умеет:</p>
<p><img src="22-sockets/sockets/Untitled%201.png" alt="Untitled" /></p>
<p>Например, пока пакет не дошёл до <em>хоста</em> (компьютера) – адресата, никто* не смотрит на заголовки транспортного уровня. Благодаря этому поверх имеющейся инфраструктуры межсетевого уровня можно реализовывать новые способы обмена информацией.</p>
<p>Как правило, протоколы прикладного уровня реализованы в userspace (в программах и библиотеках), транспортного и межсетевого — в ядре ОС, а канальный уровень делят между собой ОС и аппаратура.</p>
<p>На межсетевом уровне появляется глобальная адресация: у каждого хоста в сети есть уникальный идентификатор — <em>адрес</em>. Адрес IPv4 — 4 байта, их записывают в десятичной системе: <code>92.242.58.220</code>. Адрес IPv6 — 16 байт, их записывают в 16-ричной системе двухбайтовыми последовательностями через двоеточие: <code>2a02:6b8::2:242</code> (там, где два двоеточия подряд, подразумевается последовательность нулевых байт).</p>
<p>Протокол TCP представляет абстракцию “трубы с данными”, похожей на канал в Unix: гарантируется надёжная доставка данных в изначальной последовательности, не сохраняются границы между отдельными записями в канал. Протокол UDP представляет абстракцию “голубиной почты”: можно отправлять <em>датаграммы</em> — отдельные фрагменты данных известного размера, которые могут дойти до получателя в произвольном порядке, дойти несколько раз или не дойти вовсе.</p>
<p>TCP и UDP используют адрес межсетевого уровня и добавляют ещё 16 бит, которые называются «<em>порт</em>». Есть well-known порты, которые обычно используются для разных надобностей (см. <code>/etc/services</code>): например, сервер HTTP обычно использует порт 80.</p>
<h3 id="Ну-и-теперь-собственно-сокеты"><a class="header" href="#Ну-и-теперь-собственно-сокеты">Ну и теперь собственно сокеты</a></h3>
<p>POSIX даёт нам слой абстракции поверх протоколов транспортного уровня и ниже. Абстракция называется <a href="https://en.wikipedia.org/wiki/Berkeley_sockets">sockets</a> (гнёзда). В userspace сокет виден как файловый дескриптор.</p>
<p>Создаём сокет (<a href="https://man7.org/linux/man-pages/man2/socket.2.html">man 2 socket</a>):</p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int socket(int domain, int type, int protocol);
</code></pre>
<p>Параметр domain выбирает используемый протокол межсетевого уровня (ну примерно). Нам будут интересны три варианта:</p>
<pre><code>Name         Purpose                                    Man page
AF_INET      IPv4 Internet protocols                    ip(7)
AF_INET6     IPv6 Internet protocols                    ipv6(7)
AF_UNIX      Local communication                        unix(7)
</code></pre>
<p>Сокеты бывают как минимум двух типов (параметр type): потоковые и датаграммные (ср. TCP и UDP). Для первых хорошо подходят стандартные операции read/write, для вторых не очень.</p>
<pre><code>       SOCK_STREAM     Provides sequenced, reliable, two-way, connection-based
                       byte  streams.

       SOCK_DGRAM      Supports datagrams (connectionless, unreliable messages
                       of a fixed maximum length).
</code></pre>
<p>protocol мы будем обычно указывать равным нулю, чтобы ОС выбрала за нас стандартный протокол нужного типа (TCP для AF_INET/SOCK_STREAM, UDP для AF_INET/SOCK_DGRAM), но можно и явно указать IPPROTO_TCP или IPPROTO_UDP.</p>
<h3 id="Где-бы-взять-адрес"><a class="header" href="#Где-бы-взять-адрес">Где бы взять адрес</a></h3>
<p>Допустим, мы хотим соединиться с хостом <a href="http://ya.ru/">ya.ru</a> по протоколу HTTPS. Мы пока не знаем, есть ли у хоста адрес IPv6 или IPv4 и каковы эти адреса. Нам нужно обратиться к серверу DNS (Domain Name System) и спросить у него. Ещё неплохо бы посмотреть в /etc/services, какого типа сокет нам понадобится (stream или datagram) и какой использовать порт.</p>
<p>Для этого нам дана функция getaddrinfo:</p>
<pre><code class="language-c">       int getaddrinfo(const char *node, const char *service,
                       const struct addrinfo *hints,
                       struct addrinfo **res);

       void freeaddrinfo(struct addrinfo *res);

       const char *gai_strerror(int errcode);

       struct addrinfo {
               int              ai_flags;
               int              ai_family;
               int              ai_socktype;
               int              ai_protocol;
               socklen_t        ai_addrlen;
               struct sockaddr *ai_addr;
               char            *ai_canonname;
               struct addrinfo *ai_next;
       };
</code></pre>
<p>Попробуем распечатать адреса, которые она нам возвращает. Смотреть на это без боли невозможно:</p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
#include &lt;stdio.h&gt;
#include &lt;arpa/inet.h&gt;

int main(int argc, char* argv[]) {
    if (argc != 3) {
        fprintf(stderr, &quot;Usage: %s NODE SERVICE\n&quot;, argv[0]);
        return 1;
    }   
    struct addrinfo *res = NULL;
    int gai_err;
    if (gai_err = getaddrinfo(argv[1], argv[2], NULL, &amp;res)) {
        fprintf(stderr, &quot;gai error: %s\n&quot;, gai_strerror(gai_err));
        return 2;
    }   
    for (struct addrinfo *ai = res; ai; ai = ai-&gt;ai_next) {
        char buf[1024];
        printf(&quot;ai_flags=%d, ai_family=%d, ai_socktype=%d\n&quot;,
                ai-&gt;ai_flags, ai-&gt;ai_family, ai-&gt;ai_socktype);
        struct sockaddr_in *inet;
        struct sockaddr_in6 *inet6;
        switch (ai-&gt;ai_family) {
            case AF_INET:
                inet = (struct sockaddr_in *)ai-&gt;ai_addr;
                printf(&quot;\taddress: %s, port: %hu\n&quot;,
                    inet_ntop(ai-&gt;ai_family, &amp;inet-&gt;sin_addr,
                        buf, sizeof(buf)),
                    htons(inet-&gt;sin_port));
                break;
            case AF_INET6:
                inet6 = (struct sockaddr_in6 *)ai-&gt;ai_addr;
                printf(&quot;\taddress: %s, port: %hu\n&quot;,
                    inet_ntop(ai-&gt;ai_family, &amp;inet6-&gt;sin6_addr,
                        buf, sizeof(buf)),
                    htons(inet6-&gt;sin6_port));
                break;
            default:
                printf(&quot;\tunknown address family\n&quot;);
        }
    }   
    freeaddrinfo(res);
}
</code></pre>
<p>Так или иначе, теперь у нас есть адреса, <del>по которым найдём сервиса́</del> и можно создавать сокеты подходящих типов и пробовать устанавливать соединения.</p>
<h3 id="Потоковые-сокеты"><a class="header" href="#Потоковые-сокеты">Потоковые сокеты</a></h3>
<p>Есть две стороны: клиент и сервер.</p>
<p>Клиент:</p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

int create_connection(char* node, char* service) {
    struct addrinfo *res = NULL;
    int gai_err;
    struct addrinfo hint = {
        .ai_family = AF_UNSPEC,     // можно и AF_INET, и AF_INET6
        .ai_socktype = SOCK_STREAM, // но мы хотим поток (соединение)
    };
    if (gai_err = getaddrinfo(node, service, &amp;hint, &amp;res)) {
        fprintf(stderr, &quot;gai error: %s\n&quot;, gai_strerror(gai_err));
        return -1;
    }
    int sock = -1;
    for (struct addrinfo *ai = res; ai; ai = ai-&gt;ai_next) {
        sock = socket(ai-&gt;ai_family, ai-&gt;ai_socktype, 0);
        if (sock &lt; 0) {
            perror(&quot;socket&quot;);
            continue;
        }
        if (connect(sock, ai-&gt;ai_addr, ai-&gt;ai_addrlen) &lt; 0) {
            perror(&quot;connect&quot;);
            close(sock);
            sock = -1;
            continue;
        }
        break;
    }
    freeaddrinfo(res);
    return sock;
}

int main(int argc, char* argv[]) {
    if (argc != 3) {
        fprintf(stderr, &quot;Usage: %s NODE SERVICE\n&quot;, argv[0]);
        return 1;
    }
    int sock = create_connection(argv[1], argv[2]);
    if (sock &lt; 0) {
        return 1;
    }
    char* msg = &quot;hello world\n&quot;;
    write(sock, msg, strlen(msg));
    close(sock);
}
</code></pre>
<p>Сервер:</p>
<pre><code class="language-c">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netdb.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

int create_listener(char* service) {
    struct addrinfo *res = NULL;
    int gai_err;
    struct addrinfo hint = {
        .ai_family = AF_UNSPEC,
        .ai_socktype = SOCK_STREAM,
        .ai_flags = AI_PASSIVE,
    };
    if (gai_err = getaddrinfo(NULL, service, &amp;hint, &amp;res)) {
        fprintf(stderr, &quot;gai error: %s\n&quot;, gai_strerror(gai_err));
        return -1;
    }
    int sock = -1;
    for (struct addrinfo *ai = res; ai; ai = ai-&gt;ai_next) {
        sock = socket(ai-&gt;ai_family, ai-&gt;ai_socktype, 0);
        if (sock &lt; 0) {
            perror(&quot;socket&quot;);
            continue;
        }
        if (bind(sock, ai-&gt;ai_addr, ai-&gt;ai_addrlen) &lt; 0) {
            perror(&quot;bind&quot;);
            close(sock);
            sock = -1;
            continue;
        }
        if (listen(sock, SOMAXCONN) &lt; 0) {
            perror(&quot;listen&quot;);
            close(sock);
            sock = -1;
            continue;
        }
        break;
    }
    freeaddrinfo(res);
    return sock;
}

int main(int argc, char* argv[]) {
    if (argc != 2) {
        fprintf(stderr, &quot;Usage: %s SERVICE\n&quot;, argv[0]);
        return 1;
    }
    int sock = create_listener(argv[1]);
    if (sock &lt; 0) {
        return 1;
    }
    int connection = accept(sock, NULL, NULL);
    char* msg = &quot;hello world\n&quot;;
    write(connection, msg, strlen(msg));
    close(sock);
}
</code></pre>
<h3 id="Датаграммные-сокеты"><a class="header" href="#Датаграммные-сокеты">Датаграммные сокеты</a></h3>
<pre><code class="language-c">       ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                      const struct sockaddr *dest_addr, socklen_t addrlen);

       ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                        struct sockaddr *src_addr, socklen_t *addrlen);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Процессы"><a class="header" href="#Процессы">Процессы</a></h1>
<h2 id="Важные-команды"><a class="header" href="#Важные-команды">Важные команды</a></h2>
<h3 id="ps"><a class="header" href="#ps">ps</a></h3>
<pre><code>$ ps [OPTIONS] # информация о запущенных процессах
</code></pre>
<p>Пример использования:</p>
<pre><code>$ ps aux
</code></pre>
<ul>
<li>Опция <code>a</code> указывает ps вывести на дисплей процессы всех пользователей, за исключением тех процессов, которые не связаны с терминалом и процессами группы лидеров.</li>
<li>Опция <code>x</code> в ps перечисляет процессы без управляющего терминала. В основном это процессы, которые запускаются во время загрузки и работают в фоновом режиме.</li>
<li>Опция <code>e</code> указывает ps отобразить все процессы.</li>
<li>Опция <code>f</code> — полноформатный список, который содержит подробную информацию о процессах.</li>
</ul>
<h3 id="proc"><a class="header" href="#proc">proc</a></h3>
<p><code>/proc</code> — это виртуальная файловая система. Ее основная задача — получение состояния системы и частично выполнение управляющих действий.</p>
<pre><code>$ ls /proc # вывод в консоль директории виртуальных каталогов и подкаталогов
</code></pre>
<h2 id="Что-такое-процесс"><a class="header" href="#Что-такое-процесс">Что такое процесс</a></h2>
<ul>
<li><em>Процесс</em> - это запись во внутренних структурах ядра, в которую ядро записывает ресурсы и планирует выполнение.
Программа, которую мы написали и запустили - это <em>процесс</em>.</li>
<li>У процесса есть своя виртуальная память и таблица файловых дескрипторов.</li>
</ul>
<h2 id="Параметры-процеса"><a class="header" href="#Параметры-процеса">Параметры процеса</a></h2>
<ul>
<li><code>USER</code> - от имени какого пользователя выполняется процесс. Стандартный пример: <code>root</code>.</li>
<li><code>PID</code> - идентификатор процесса, у процессов выполняющихся в одно время он разный.</li>
<li><code>STAT</code> - статус процесса. Примеры статусов: <code>S</code> - процесс в состоянии ожидания, <code>R</code> - выполняющийся процесс, <code>D</code> - процесс ожидает ввода/вывода.</li>
</ul>
<h3 id="Нужные-системные-вызовы"><a class="header" href="#Нужные-системные-вызовы">Нужные системные вызовы</a></h3>
<ul>
<li>
<p>Системный вызов <code>sleep</code> - процесс будет спать в течение заданного количества секунд.</p>
</li>
<li>
<p>Системный вызов <code>pause</code> - заставляет вызывающий процесс спать до тех пор, пока не поступит сигнал, который либо завершит процесс, либо вызовет функцию, ловящую данный сигнал.</p>
</li>
<li>
<p>Системный вызов <code>wait</code> приостанавливает выполнение вызывающего процесса пока не завершится один из его дочерних процессов.</p>
</li>
</ul>
<h2 id="Как-породить-новый-процесс"><a class="header" href="#Как-породить-новый-процесс">Как породить новый процесс?</a></h2>
<ul>
<li>Системный вызов <code>fork</code> - полностью копирует процесс, который его вызвал. Важно понимать, что хоть у них пространства виртуальной памяти изначально идентичные (сразу после копирования), они всё же отдельные. То есть изменение переменной в одном процессе не поменяет её в другой.</li>
</ul>
<h3 id="Как-это-использовать"><a class="header" href="#Как-это-использовать">Как это использовать</a></h3>
<pre><code>#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

int main () {
    fork();
    printf(&quot;hello world from %d\n&quot;, getpid()); // id процесса - это целое число
}
</code></pre>
<p>Данный код приведёт к тому, что pid выведется дважды, и это будут два разных числа. Важно понимать, что зацикливания не произойдёт, так как новый процесс начнёт выполняться с момента строго после <code>fork()</code>. Более наглядно это будет, если послетреть на output кода ниже.</p>
<pre><code>#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

int main () {
    printf(&quot;parent process\n&quot;);
    fork();
    printf(&quot;hello world from %d\n&quot;, getpid());
}
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>parent process
hello world from 2991610
hello world from 2991611
</code></pre>
<p>Так как виртуальная память копируется, то любые изменения переменных в склонированном процессе будут локальными, однако иметь одинаковые адреса. Наглядно это можно увидеть из примера кода ниже.</p>
<pre><code>#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

int x = 0;

int main () {
    fork();
    ++x;
    sleep(1); // для надёжности усыпим процесс, чтобы x успели поменять оба
    printf(&quot;x = %d, &amp;x = %d\n&quot;, x, &amp;x);
}
</code></pre>
<p><strong>OUTPUT:</strong></p>
<pre><code>x = 1, &amp;x = 0x55f9 // разумеется реальный адрес будет длиннее,
x = 1, &amp;x = 0x55f9 // но для наглядности взят короткий
</code></pre>
<p>Как же тогда в самом процессе понять дочерний он или родительский? Посмотреть на возвращаемое значение функции <code>fork</code>. В родительский процесс она возвращает <code>PID</code> дочернего, а в дочерний возвращает <code>0</code>. В случае ошибки возвращаемое значение равняется <code>-1</code>.
Из этого также следует, что <code>PID</code> начинаются с <code>1</code>.</p>
<p>Задан ли порядок выполнения родительского и дочернего процессов? Нет. Они могут выполняться в любом порядке и никак не синхронизированы.</p>
<p>Зачем нам вообще нужно, чтобы в системе было много процессов? Например, чтобы разные пользователи могли запускать программы, или один пользователь мог одновременно запустить несколько программ.</p>
<p>Что будет, если родительский процесс убить до того, как дочерний завершится? Для этого давайте посмотрим как будет выглядеть консоль целиком после выполнения кода ниже.</p>
<pre><code>#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

int main () {
    pid_t id = fork();
    if (id == 0) {
        printf(&quot;child process\n&quot;);
        sleep(2);
    } else {
        print(&quot;parent process\n&quot;);
    }
    printf(&quot;Hello there\n&quot;);
}
</code></pre>
<p><img src="19-process/kill_parent.png" alt="Что делает дочерний процесс, если родитель уже умер" /></p>
<p>Что нужно знать про системный вызов <code>wait</code>? Если дочерний процесс уже завершился, а родительский ещё нет, то дочерний переходит с состояние <code>zombie/defunct process</code>, так как понимает, что родительский процесс всё ещё может захотеть вызвать <code>wait</code>.</p>
<h2 id="Системный-вызов-для-файлов"><a class="header" href="#Системный-вызов-для-файлов">Системный вызов для файлов</a></h2>
<h3 id="Что-происходит-при-вызове-open"><a class="header" href="#Что-происходит-при-вызове-open">Что происходит при вызове open?</a></h3>
<ul>
<li>Создаётся file descript<strong>ion</strong>.</li>
<li>В таблицу c file descript<strong>ors</strong> передаётся ссылка на данный file descript<strong>ion</strong>.</li>
<li>Индекс данной ссылки возвращается как результат системного вызова.</li>
</ul>
<p>У процесса таблица file descript<strong>ors</strong> представляет из себя массив из указателей на file descript<strong>ions</strong>.</p>
<p>Сами file descript<strong>ions</strong> никак не привязаны к процессу.</p>
<h3 id="Что-происходит-с-файловыми-структурами-при-системных-вызовах"><a class="header" href="#Что-происходит-с-файловыми-структурами-при-системных-вызовах">Что происходит с файловыми структурами при системных вызовах?</a></h3>
<ul>
<li><code>fork</code>:
<ul>
<li>struct file - увеличения счётчика указателей</li>
<li>таблица file descript<strong>ors</strong> никак не изменится</li>
</ul>
</li>
<li><code>close</code>:
<ul>
<li>уменьшение счётчика указателей</li>
<li>file descript<strong>ion</strong> уничтожается, если на файл больше никто не указывает</li>
</ul>
</li>
<li><code>lseek</code>:
<ul>
<li>меняется позиция в file descript<strong>ion</strong></li>
</ul>
</li>
</ul>
<p><strong>Важный факт:</strong> для разных процессов, читающих один и тот же файл, позиция считывания общая. То есть, когда читает один из процессов, указатель откуда чтение продолжится сдвигается для всех.</p>
<h2 id="Атомарность"><a class="header" href="#Атомарность">Атомарность</a></h2>
<p>В чём состоит вопрос?
Не получится ли так, что мы из двух процессов выполняем чтение или запись с одним и тем же файлом, и позиции чтения и записи будут как-то несогласованы (помним, что указатель на текущую позицию в файле общий для процессов)?</p>
<h3 id="Пример-не-атомарности"><a class="header" href="#Пример-не-атомарности">Пример не атомарности</a></h3>
<p><img src="19-process/atom_ex.png" alt="Пример" /></p>
<p>Решение: добавить флаг <code>O_EXCL</code>, таким образом файл не будет создан заново.</p>
<h3 id="Пример-для-логирования"><a class="header" href="#Пример-для-логирования">Пример для логирования</a></h3>
<p>Использование флага <code>O_APPEND</code> будет выполнять перемещение указателя на место записи в файле в самый конец и саму запись в данную позицию (то есть в конец файла) <strong>атомарно</strong>.</p>
<h3 id="Ужасающий-пример-отсутствия-атомарности"><a class="header" href="#Ужасающий-пример-отсутствия-атомарности">Ужасающий пример отсутствия атомарности</a></h3>
<p>POSIX (стандарт) - не даёт гарантий атомарности на запись или чтение из файла. Например результатом <code>write(&quot;123&quot;)</code> и <code>write(&quot;abc&quot;)</code> из разных процессов может быть <code>&quot;1a2b3c&quot;</code>.</p>
<p>Но можно расслабиться, Linux запишет всё без перемешивания.</p>
<h2 id="shebang"><a class="header" href="#shebang">shebang</a></h2>
<p>При добавлении в скрипт записи вида <code>#!&lt;address&gt;</code>, запускается не сам скрипт, а интерпретатор <code>&lt;address&gt;</code>.</p>
<p>Пример:</p>
<pre><code>#!/usr/bin/python3

print(&quot;hello&quot;)
</code></pre>
<p>bash не знает, что такое <code>print</code>, зато <code>/usr/bin/python3</code> знает.</p>
<h2 id="Семейство-exec"><a class="header" href="#Семейство-exec">Семейство exec</a></h2>
<h3 id="Что-происходит-при-вызове"><a class="header" href="#Что-происходит-при-вызове">Что происходит при вызове</a></h3>
<ul>
<li>Текущий процесс остаётся без изменений</li>
<li>Исчезает только виртуальная память и появляется новое пространство виртуальной памяти</li>
<li>В данную виртуальную память загружается бинарный файл и начинается его исполнение</li>
</ul>
<h3 id="Пример-для-понимания"><a class="header" href="#Пример-для-понимания">Пример для понимания</a></h3>
<pre><code>#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

int main() {
    execv(...);
    perror(&quot;Error\n&quot;);
}
</code></pre>
<p>Сообщение об ошибке не выведется, так как данный процесс начнёт исполнять уже другой бинарный файл.</p>
<h3 id="Так-как-же-тогда-использовать"><a class="header" href="#Так-как-же-тогда-использовать">Так как же тогда использовать</a></h3>
<pre><code>#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

int main() {
    pid_t child = fork();
    if (child == 0) { // если мы в дочернем процессе
        execv(...);
    }
    int status;
    wait(&amp;status);
    printf(&quot;Some code here&quot;\n);
}
</code></pre>
<p>Здесь мы имеем, что дочерний процесс отдаст свои ресурсы под выполнение бинарного файла, а родительский продолжит выполнять свой код дальше. <code>wait</code> добавили, чтобы родительский процесс сначала дождался выполнения дочернего процесса.</p>
<h3 id="dup2"><a class="header" href="#dup2">dup2</a></h3>
<p>Системный вызов делает так, чтобы определенный файловый дескриптор (передаётся по номеру), смотрел туда же, куда и другой файловый дескприптор (тоже передаётся по номеру).</p>
<p>Пример использования:</p>
<p><img src="19-process/dup2.png" alt="dup2" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shared_mem"><a class="header" href="#shared_mem">shared_mem</a></h1>
<p>Пока будем организовывать себе разделяемую память по старинке: <code>mmap(MAP_SHARED); fork()</code>.</p>
<h3 id="Неожиданности-на-уровне-ассемблера"><a class="header" href="#Неожиданности-на-уровне-ассемблера">Неожиданности на уровне ассемблера</a></h3>
<p>Мы привыкли думать про компьютер как про машину фон Неймана: есть отдельные инструкции, которые выполняются в определённой последовательности, и результаты выполнения каждой “видны” всем последующим:</p>
<pre><code class="language-c">mov $3, x
mov x, %eax  // очевидно, теперь eax == 3
</code></pre>
<p>Так мы всегда писали программы, так видели их в отладчике.</p>
<p>Можно было бы ожидать, что когда мы пишем многопоточную программу, то из инструкций отдельных потоков (перемежающихся в каком-то порядке) можно составить эквивалентную однопоточную:</p>
<pre><code class="language-c">CPU    1            CPU    2            Однопоточное исполнение
                                        Sequential consistency

mov $3, x ----------------------------&gt; mov $3, x
                    mov $4, y  -------&gt; mov $4, y
mov y, %eax --------------------------&gt; mov y, %eax
                    mov x, %ecx ------&gt; mov x, %ecx
</code></pre>
<p>Но оказывается, что на реальном процессоре может быть вот так:</p>
<pre><code class="language-c">// Thread 1        // Thread 2

// start with x == 0, y == 0

mov $1, x          mov $2, y
mov y, %eax        mov x, %ecx

// %eax == 0, %ecx == 0
</code></pre>
<p>Как ни перемежай эти инструкции, в однопоточной программе такой результат невозможен.</p>
<p>Дело в том, что мы для скорости добавляем в процессоры кэши:</p>
<p><img src="25-shared-mem/Untitled.png" alt="Untitled" /></p>
<p>Нашу любимую архитектуру x86 можно представить так (Total Store Order):</p>
<p><img src="25-shared-mem/Untitled%201.png" alt="Untitled" /></p>
<p>Возможно, один процессор записал в свой write buffer  <code>x=1</code> , другой <code>y=2</code>, но пока не записали это в общую память, а прочитали из общей памяти старые значения.</p>
<p>Тем не менее на x86 не может быть такого:</p>
<pre><code class="language-c">// start with x=0, y=0

// Thread 1           // Thread 2
x = 1                 r1 = y
y = 1                 r2 = x

                      // **r1 = 1, r2 = 0**
                      // более поздняя запись произошла,
                      // а более ранняя нет
</code></pre>
<p>Но такое может быть на архитектуре ARM:</p>
<p><img src="25-shared-mem/Untitled%202.png" alt="Untitled" /></p>
<p>Чтобы можно было писать программы, процессор гарантирует некоторую <em>модель памяти</em>: что может происходить, а что нет.</p>
<p>Названия: sequential consistency, TSO, strong/relaxed memory model.</p>
<p>Статья про модели памяти: <a href="https://research.swtch.com/hwmm">https://research.swtch.com/hwmm</a></p>
<p>Документация Intel (см. раздел 8.2.3 Examples Illustrating the Memory-Ordering Principles):</p>
<p><a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html</a> (только через VPN)</p>
<h3 id="rmw--read-modify-write"><a class="header" href="#rmw--read-modify-write">RMW — read, modify, write</a></h3>
<p>Счётчик:</p>
<pre><code class="language-c">lock incl x  // из разных потоков
// -&gt; load x, %r...; inc %r...; store %r..., x

mfence   // full barrier  
lfence   // load fence
sfence   // store fence
</code></pre>
<h3 id="Неожиданности-на-уровне-ЯВУ"><a class="header" href="#Неожиданности-на-уровне-ЯВУ">Неожиданности на уровне ЯВУ</a></h3>
<p>(То есть Языка Высокого Уровня.)</p>
<p>Компилятор ничего не знает про разные потоки исполнения.</p>
<pre><code class="language-c">// Thread 1           // Thread 2
x = 1;                while(done == 0) { /* loop */ }
done = 1;             print(x);
</code></pre>
<p>Цикл может 1) выполняться бесконечно, 2) не выполняться совсем, 3) выполняться как ожидается.</p>
<p>Можно поиграться с разными вариантами:</p>
<ul>
<li>
<p>на Си <a href="https://godbolt.org/z/Kv79K4cT6">https://godbolt.org/z/Kv79K4cT6</a>,</p>
</li>
<li>
<p>на С++ <a href="https://godbolt.org/z/vqPbecYqo">https://godbolt.org/z/vqPbecYqo</a></p>
</li>
</ul>
<p>Напечатано может быть 0, 1 или что-нибудь ещё.</p>
<h3 id="atomics"><a class="header" href="#atomics">Atomics</a></h3>
<p>C: <code>_Atomic</code>.</p>
<p>Atomic vs volatile: <a href="https://godbolt.org/z/zT55bhzs8">https://godbolt.org/z/zT55bhzs8</a></p>
<p>Более уместно было бы название <em>synchronizing atomics</em>.</p>
<p>Как атомарные операции компилируются на разных платформах:</p>
<p><a href="https://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html">https://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html</a></p>
<pre><code class="language-c">Thread 1        Thread 2
W(x, 1)                    // happens before SW(done)
SW(done, 1) ---  SR(done)  // happens before R(x)
	             R(x)      // happens after SR(m)

// W(x, 1) → SW → SR → R(x)

↓               ↓
program order   program order

mov $1, x       mov done, %eax  // 1
mov $1, done    mov x, %ecx 
</code></pre>
<p>Линус про _Atomic: <a href="https://gcc.gnu.org/legacy-ml/gcc/2012-02/msg00027.html">Re: Memory corruption due to word sharing</a> (”it's not the &quot;state&quot; that is accessed concurrently. It's the code.”).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parallel-2"><a class="header" href="#parallel-2">parallel-2</a></h1>
<h3 id="rmw"><a class="header" href="#rmw">RMW</a></h3>
<p>x86: префикс <a href="https://www.felixcloutier.com/x86/lock">lock</a>:</p>
<pre><code class="language-c">lock add/sub/xor/...

xchg %r32, m32  //  exchange; &quot;lock&quot; implied

lock xadd %r32, m32  //  { tmp = m32; m32 += r32; r32 = tmp; }

lock cmpxchg %r32, m32  // CAS — compare and swap
// Compare %eax with m32.
// If equal, set ZF and load r32 into m32.
// Else, clear ZF and load m32 into %eax.
</code></pre>
<p>C11: <a href="https://en.cppreference.com/w/c/atomic">stdatomic.h</a></p>
<pre><code class="language-c">#include &lt;stdatomic.h&gt;

_Bool atomic_compare_exchange_strong(volatile A *object, C *expected, C desired);
_Bool atomic_compare_exchange_weak(volatile A *object, C *expected, C desired);
/*
Atomically, compares the value pointed to by object for equality
with that in expected, and if true, replaces the value pointed to by object with
desired, and if false, updates the value in expected with the value pointed to by
object.
Returns the result of the comparison.
*/

if (weak &amp;&amp; !x86) {
	sometimes {
		return false;  // weak-версия иногда фейлится просто так
		// load-linked + store-conditional на ARM
	}
}
atomically {
  bool equal = (*object == *expected);
  *expected = *object;
  if (equal) {
		*object = desired;
	}
	return equal;
}
</code></pre>
<p>C++: <a href="https://en.cppreference.com/w/cpp/atomic">cppreference</a>.</p>
<h3 id="Критические-секции-мьютексы"><a class="header" href="#Критические-секции-мьютексы">Критические секции (мьютексы)</a></h3>
<p>Бывают вещи, которые нужно сделать атомарно, а готовой atomic/RMW операции для этого нет:</p>
<pre><code class="language-c">struct list {
	int val;
  struct list* next;
}

void push(struct list** head, int value) {
	struct list *node = calloc(1, sizeof(*node));
  node-&gt;val = value;
	spin_lock(lock);
  {
    node-&gt;next = *head;
    *head = node;
  }
  spin_unlock(lock);
}

/*
Thread 0         Thread 1
*head = node;
lock = 0;  ----&gt; lock == 0
                 node-&gt;next = *head;
*/
</code></pre>
<p>Mutex — от MUTual EXclusion.</p>
<p>Перед тем, как построить мьютекс, построим спинлок.</p>
<h3 id="spinlock"><a class="header" href="#spinlock">Spinlock</a></h3>
<pre><code class="language-c">int spinlock;
// 0 — unlocked
// 1 — locked
</code></pre>
<p>Будем пользоваться примитивом Compare-And-Swap:</p>
<pre><code class="language-c">cmpxchg(var, expected, desired) {
	atomically {
		old = var;
		if (var == expected) {
			var = desired;
		}
		return old;
	}
}
</code></pre>
<p>Спинлок:</p>
<pre><code class="language-c">typedef _Atomic int spinlock;

// Неэффективный, но работающий спинлок
void spin_lock(spinlock *s) {
	while (cmpxchg(*s, 0, 1) != 0) { asm volatile (&quot;pause&quot;); }
}

void spin_unlock(spinlock *s) {
	*s = 0;
}
</code></pre>
<p>Спинлок отлично работает, когда защищает пару инструкций, но бесконечно тратит ресурсы, если нужно подождать подольше. На этот случай нам нужен способ остановиться и подождать, а с этим нам может помочь только ядро.</p>
<h3 id="Фьютексы"><a class="header" href="#Фьютексы">Фьютексы</a></h3>
<p>Примитив синхронизации в ядре Linux (<a href="https://en.wikipedia.org/wiki/Futex#Operations">википедия</a>):</p>
<pre><code class="language-c">FUTEX_WAIT(addr, val)
If the value stored at the address *addr* is *val*, puts the current thread to sleep.

FUTEX_WAKE(addr, num)
Wakes up *num* threads waiting on the address *addr*.
</code></pre>
<p>(На любой платформе addr — адрес 32-битного значения.)</p>
<p>(Fast Userspace muTual EXclusion.)</p>
<p>Теперь можно сделать себе (простенький, не production ready) мьютекс:</p>
<pre><code class="language-c">struct mutex {
	_Atomic uint32_t lock;
	_Atomic uint32_t waiters;
};

void mutex_lock(struct mutex *m) {
	while (cmpxchg(m-&gt;lock, 0, 1) != 0) {
		m-&gt;waiters++;
		futex_wait(&amp;m-&gt;lock, 1);
		m-&gt;waiters--;
	}
}

void mutex_unlock(struct mutex *m) {
	m-&gt;lock = 0;
  if (m-&gt;waiters &gt; 0) {
		futex_wake(&amp;m-&gt;lock, 1);
	}
}

struct object {
	struct mutex m;
	int refcount;
}
</code></pre>
<p>Настоящий мьютекс занимает одно 32-битное значение и немножко ждёт как спинлок в надежде, что не придётся делать futex_wait, но в целом устроен так же.</p>
<p>Сравнить реализации: <a href="../../git.musl-libc.org/cgit/musl/tree/src/thread/pthread_mutex_timedlock2e5e.html?h=v1.1.15">мьютекс из musl</a>, <a href="../../github.com/tpn/pdfs/blob/master/Futexes%20Are%20Tricky%20-%20Ulrich%20Drepper%20(2011).html">статья Дреппера про фьютексы</a>.</p>
<p>Contention («конкуренция»?). Оптимизируем uncontended case.</p>
<h3 id="Ну-теперь-можно-и-треды-создавать"><a class="header" href="#Ну-теперь-можно-и-треды-создавать">Ну, теперь можно и треды создавать</a></h3>
<p>Threads (нити, треды, легковесные процессы) — потоки исполнения в общем адресном пространстве.</p>
<p>Как сделать себе такую штуку в Linux: <a href="https://man7.org/linux/man-pages/man2/clone.2.html">https://man7.org/linux/man-pages/man2/clone.2.html</a> (читать про CLONE_THREAD).</p>
<p><a href="https://man7.org/linux/man-pages/man7/pthreads.7.html">man pthreads</a></p>
<p><a href="../../github.com/cloudius-systems/musl/blob/00733dd1cf791d13ff6155509cf139a5f7b2eecb/src/thread/pthread_create.html">pthread_create в musl</a></p>
<p>Thread safety стандартной библиотеки языка Си: <a href="https://man7.org/linux/man-pages/man7/attributes.7.html">https://man7.org/linux/man-pages/man7/attributes.7.html</a> (<a href="https://man7.org/linux/man-pages/man3/printf.3.html#ATTRIBUTES">пример про printf</a>).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>

<!-- Mirrored from caos2023.myltsev.ru/lectures/print.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 15 Jan 2024 12:00:11 GMT -->
</html>
