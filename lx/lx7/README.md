Практика студентов Финансового университета
=========

# Сетевые системы и приложения


- # Основы скриптов на bash

- - # Практика: Ваш первый сценарий

#### Основное задание

В данной работе мы напишем для вывода фразы "Hello world!" специальный сценарий.

1. Создайте файл _hello.sh_.
2. Откройте данный файл для редактирования в текстовом редакторе.
3. Запишите первую строку файла: _#!/bin/bash_. Это так называемый "шебанг" - специальная инструкция, сообщающая операционной системе, что данный файл нужно воспринимать именно как Bash-сценарий и использовать для его выполнения командную оболочку Bash.
4. Запишите вторую строку в файл: _echo "Hello world!"_. Данная команда выводит на экран фразу "Hello world!".
5. Выполните полученный сценарий: _bash hello.sh_
6. Для того чтобы сценарий можно было выполнить как обычную программу, нужно сделать файл сценария исполняемым: _chmod +x hello.sh_
7. Попробуйте запустить сценарий как обычную программу: _./hello.sh_.
8. Попробуйте запустить сценарий без указания пути: _hello.sh_. Данная команда не работает, так как она отсутствует в перечне путей в переменной $PATH. $PATH содержит список каталогов, разделенных “:”, в которых командная оболочка последовательно ищет исполняемый файл.
9. Создайте в домашнем каталоге каталог _bin_ и переместите туда файл _hello.sh_.
10. Добавьте директорию _\~/bin_ в переменную _$PATH_ оператором конкатенации строк _bash_.
11. Попробуйте запустить сценарий без указания пути: _hello.sh_. Так как сценарий теперь расположен по пути, который есть в _$PATH_, команда должна сработать и вывести на экран "Hello world!".

Примечание. Данный сценарий будет доступен только текущему пользователю. Для того чтобы сценарий работал у всех пользователей системы, его нужно скопировать в каталог _/usr/local/bin_ (для этого потребуются права _root_).

#### Задания для самостоятельного выполнения

1. Разработать сценарий, который создаёт каталог _/tmp/shared_ и устанавливает на него права доступа _rwxrwxrwx_.
2. Получите и выведите на экран, используя переменные окружения, имена текущего каталога и домашнего каталога.
3. Создайте новую переменную _NEWVAR_ со значением _1982_.
4. Создайте скрипт, который создает пользователя с именем, переданным скрипту как первый параметр и паролем, который передан скрипту как второй параметр.
5. (\*) Создать скрипт, осуществляющий вывод меню, состоящего из следующих пунктов :  
    1. текущий пользователь,  
    2. объем используемой памяти,  
    3. объем дискового пространства,  
    4. запущенные процессы,  
    5. процессы, запущенные текущим пользователем,  
    6. системная дата и время,  
    7. время запуска системы  
    8. выход, 

    и вывод соответствующей информации в зависимости от выбранного пункта меню. Процесс повторять до тех пор, пока не будет выбран пункт меню «выход».

6. (\*) Создайте скрипт, который устанавливает в систему СУБД PostgerSQL, создает нового пользователя, заводит соответствующую роль в базе данных, создает базу данных в PostgerSQL, дает данному пользователю все права в этой базе, открывает к СУБД доступ по сети с удаленных машин.

Необходимые команды следует добавить в тот же файл сценария, который создавался для выполнения основного задания. Также необходимо добавить комментарии (пояснения, где какое задание выполнено).

- - # Практика: Работа с cron 

#### Основное задание


1. Пишем пустой скрипт с расширением .sh и запускаем его. Скрипт - это простой текстовый файл, в первой строке которого содержится шебанг:

```
#!/usr/bin/bash
```
2. Делаем так, чтобы скрипт можно было запускать без указания пути
3. Делаем так, чтобы скрипт инициализировал _DATE_ и записывал туда значение времени, затем выводил на экран
4. Делаем так, чтобы вместо вывода на экран создавался файл в директории подобный /_tmp/14-05-01.txt_
5. Делаем так, чтобы в файл записывалось время создания
6. Используя _CRON_ заставляем скрипт исполняться ежеминутно
7. Через 10 минут проверяем, чтобы в директории было столько же файлов, сколько прошло минут
8. Обнаруживаем ошибку
9. Используя _find_ делаем так, чтобы директория проверялась раз в 10 минут и удаляла файлы, созданные больше, чем 17 минут назад


#### Методические указания[^1]

Cron используется для планирования задач, которые будут выполняться периодически. Вы можете настроить команды или сценарии, которые будут повторяться в заданное время. Cron — один из самых полезных инструментов в Linux или UNIX. Служба(daemon) cron работает в фоновом режиме и постоянно проверяет файл _/etc/crontab_ и каталог _/etc/cron.\*/_. Он также проверяет каталог _/var/spool/cron/_.

Crontab — это команда, используемая для установки, удаления или вывода файла конфигурации cron, используемого для управления демоном cron. Каждый пользователь может иметь свой собственный файл задач _crontab_, и хотя эти файлы хранятся в _/var/spool/cron/crontabs_, они не предназначены для прямого редактирования. Вам нужно использовать команду _crontab_ для редактирования или настройки ваших собственных заданий, чтобы планировщик Cron работал корректно.

Существуют различные типы файлов конфигурации:

Системный Сrontab: Обычно используется системными службами и критическими заданиями, требующими привилегий root доступа. Шестое поле (см. ниже описание поля) — это имя пользователя которое по умолчанию присвоено команде. Это дает системе возможность запускать команды от разных пользователей.

Пользовательский crontab: Пользователь может установить свои собственные задания в программе планировщик Cron, используя команду crontab. Шестое поле — это команда для запуска, и все команды будут выполняться от пользователя, который задал их в своем собственном crontab.

Чтобы отредактировать файл crontab, введите следующую команду в командной строке оболочки Unix / Linux:

```bash
crontab -e
```

##### Синтаксис crontab (описание полей)

```
1 2 3 4 5 /path/to/command arg1 arg2
```

Где цифры обозначают:

* 1: Минуты (0-59)
* 2: Часы (0-23)
* 3: День (0-31)
* 4: Месяц (0-12 [12 == Декабрь])
* 5: День недели (0-7 [7 или 0 == sunday])
* /path/to/command — имя скрипта или команды для выполнения по расписанию

Легко запоминаемый формат:

```
* * * * * Команда, которая будет выполнена
- - - - -
| | | | |
| | | | - День недели (0 - 7) (воскресенье = 0 или 7)
| | | --- Месяц (1 - 12)
| | --- День месяца (1 - 31)
| ---- Час (0 - 23)
----- Минута (0 - 59)
```

Пример

```
# выполнять скрипт backupscript каждые 5 минут #
*/5 * * * * /root/backupscript.sh

# выполнять скрипт backupscript каждый день в час ночи #
0 1 * * * /root/backupscript.sh

# выполнять скрипт каждый месяц первого числа в три часа ночи пятнадцать минут #
15 3 1 * * /root/backupscript.sh
```

#####  Как использовать операторы?

Оператор позволяет указать несколько значений в поле. Существует три оператора:

Звездочка (\*): этот оператор задает все возможные значения для поля. Например, звездочка в поле «Часы» будет эквивалентна каждому часу, а звездочка в поле месяца будет эквивалентна каждому месяцу и т.д.

Запятая (,): Этот оператор задает список значений, например: «1,5,10,15,20,25».

Тире (-): Этот оператор задает диапазон значений, например: «5-15» дней, что эквивалентно набору «5,6,7,8,9 … …, 13,14,15», при использования оператора «Запятая».

Слеш (/): этот оператор задает значение шага, например: «0-23 /» можно использовать в поле часов, чтобы указывать выполнение команды каждый час. Шаги также разрешены после звездочки, поэтому, если вы хотите выполнять что-то каждые два часа, просто используйте «\*/2».

Используйте специальную строку, чтобы сэкономить время

Вместо первых пяти полей вы можете использовать любую из восьми специальных строк. Планировщик Cron  позволяет такую настройку. Это не только сэкономит ваше время, но и улучшит читаемость.

| Специальная строка | Значение |
|---|---|
| @reboot| Запускается только один раз при запуске.|
| @yearly| Запускается раз в год, «0 0 1 1 \*».|
| @annually | Такое же, как у @yearly|
| @monthly | Запускается раз в месяц, «0 0 1 \* \*».|
| @weekly | Выполняется раз в неделю, «0 0 \* \* 0».|
| @daily | Выполняется один раз в день, «0 0 \* \* \*».|
| @midnight | Такое же, как у @daily.|
| @hourly | Запускается один раз в час, «0 \* \* \* \*».|

Пример:

```
# Запуск команды ntpdate каждый час #
@hourly /path/to/ntpdate
```

#### Задания для самостоятельного выполнения

1. После выполнения работы просмотрите системный журнал и найдите в нем (автоматически) записи, соответствующие выполнению вашего скрипта. Подсчитайте количество запусков.
2. Напишите скрипт автоматического архивирования домашней папки. Напишите установочный скрипт, который спрашивает пользователя о периодичности архивации и автоматический добавляет скрипт в расписание.

#### Контрольные вопросы

1. Как можно запретить определенным пользователям запуск заданий планировщика?
2. Как можно просмотреть или удалить расписание текущего пользователя?
3. Что такое демонизация процесса? Зачем оно нужно?
4. Как можно пользоваться специальными папками cron для планирования задач?

#### Notes

[^1]:
     По материалам [https://blog.sedicomm.com/2017/07/24/kak-dobavit-zadanie-v-planirovshhik-cron-v-linux-unix/](https://blog.sedicomm.com/2017/07/24/kak-dobavit-zadanie-v-planirovshhik-cron-v-linux-unix/)


- - # Практика: Работа с MD5

#### Основное задание

1. Создаём пустой файл и вписываем что-нибудь
2. Копируем с сохранением всех прав в другой файл с любым названием и содержимым
3. Сравниваем контрольные суммы
4. Меняем содержимое любого из файлов и смотрим разницу в контрольных суммах
5. Создаём пользователя и задаём ему пароль
6. Разбираемся с _/etc/passwd_, _/etc/shadow, /etc/group_
7. Делаем так, чтобы, если нет файла _/tmp/passwd.backup_, _/etc/passwd_ копировался в _/tmp/passwd.backup_, а если _/tmp/passwd.backup_ есть, то сравнивался с _/etc/passwd_
8. Если различаются, то пусть копируется, если нет, пусть завершает работу скрипта


#### Методические указания[^1]

Контрольная сумма - это цифра или строка, которая вычисляется путем суммирования всех цифр нужных данных. Ее можно использовать в дальнейшем для обнаружения ошибок в проверяемых данных при хранении или передаче. Тогда контрольная сумма пересчитывается еще раз и полученное значение сверяется с предыдущим.

Контрольные суммы Linux с вычисляемые по алгоритму MD5 (Message Digest 5) могут быть использованы для проверки целостности строк или файлов. MD5 сумма - это 128 битная строка, которая состоит из букв и цифр. Суть алгоритма MD5 в том, что для конкретного файла или строки будет генерироваться 128 битный хэш, и он будет одинаковым на всех машинах, если файлы идентичны. Трудно найти два разных файла, которые бы выдали одинаковые хэши.

В Linux для подсчета контрольных сумм по алгоритму md5 используется утилита _md5sum_. Вы можете применять ее для проверки целостности загруженных из интернета iso образов или других файлов.

Эта утилита позволяет не только подсчитывать контрольные суммы linux, но и проверять соответствие. Она поставляется в качестве стандартной утилиты из набора GNU, поэтому вам не нужно ничего устанавливать.

Синтаксис команды md5sum очень прост:

```bash
md5sum опции файл
```

Опций всего несколько и, учитывая задачи утилиты, их вполне хватает:

-c - выполнить проверку по файлу контрольных сумм;

-b - работать в двоичном формате;

-t - работать в текстовом формате;

-w - выводить предупреждения о неверно отформатированном файле сумм;

--quiet - не выводить сообщения об успешных проверках.

Сначала скопируйте файл /etc/group в домашнюю папку чтобы на нем немного поэкспериментировать:

```bash
cp /etc/group groups
```

Например, давайте подсчитаем контрольную сумму для файла /etc/group:

```bash
md5sum groups
```

Или вы можете сохранить сразу эту сумму в файл для последующей проверки:

```bash
md5sum groups > groups.md5
```

Затем каким-либо образом измените этот файл, например, удалите первую строчку и снова подсчитайте контрольные суммы:

```bash
md5sum groups
```

Как видите, теперь значение отличается, а это значит, что содержимое файла тоже изменилось. Дальше верните обратно первую строчку root:x:0: и скопируйте этот файл в groups_list и

```bash
cp groups groups_list
```

Затем опять должна быть выполнена проверка контрольной суммы linux:

```bash
md5sum groups_list
```

Сумма соответствует первому варианту, даже несмотря на то, что файл был переименован. Обратите внимание, что md5sum работает только с содержимым файлов, ее не интересует ни его имя, ни его атрибуты. Вы можете убедиться, что оба файла имеют одинаковые суммы:

```bash
md5sum groups groups_list
```

Вы можете перенаправить вывод этой команды в файл, чтобы потом иметь возможность проверить контрольные суммы:

```bash
md5sum groups groups_list > groups.md5
```

Чтобы проверить, не были ли файлы изменены с момента создания контрольной суммы используйте опцию -c  или --check. Если все хорошо, то около каждого имени файла появится слово OK или ЦЕЛ:

```bash
md5sum -c groups.md5
```

Но теперь вы не можете переименовывать файлы, потому что при проверке утилита будет пытаться открыть их по имени и, естественно, вы получите ошибку. Точно так же все работает для строк:

```bash
echo -n "Losst" | md5sum -
echo -n "Losst Q&A" | md5sum -
```

Из этой статьи вы узнали как выполняется получение и проверка контрольной суммы linux для файлов и строк. Хотя в алгоритме MD5 были обнаружены уязвимости, он все еще остается полезным, особенно если вы доверяете инструменту, который будет создавать хэши.

Проверка целостности файлов Linux - это очень важный аспект использования системы. Контрольная сумма файла Linux используется не только вручную при проверке загруженных файлов, но и во множестве системных программ, например, в менеджере пакетов.


#### Задания для самостоятельного выполнения



1. Возьмите скрипт, который был создан на предыдущей лабораторной работе. Создайте установочный скрипт, который проверяет целостность скрипта, сравнивая контрольную сумму с заранее сохраненным значением. При совпадении он должен создать задачу по расписанию, а при несовпадении - выдать ошибку и завершиться.
2. Создайте скрипт, который проверяет целостность основных системных конфигурационных файлов и при обнаружении ошибки восстанавливает их из архивной копии. Добавьте возможность пересчета контрольных сумм при санкционированных изменениях (одновременное сохранение новых копий в архиве). Добавьте возможность регулярной проверки. Реализуйте все функции в одном скрипте, использующем несколько опций.

#### Контрольные вопросы

1. Какие еще существуют алгоритмы вычисления контрольных сумм?
2. Для чего применяются контрольные суммы?

#### Notes

[^1]:
     По материалам [https://losst.ru/proverka-kontrolnoj-summy-linux](https://losst.ru/proverka-kontrolnoj-summy-linux) 


