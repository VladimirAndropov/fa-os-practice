
Практика студентов Финансового университета
=========

# Сетевые системы и приложения

- # Права и пользователи

- - # Практика: Управление пользователями

#### Основное задание



1. Ознакомиться с содержимым файлов: 

```
/etc/passwd
/etc/shadow
/etc/group
```


2. Создать следующие группы: 

```
workers
teachers
students
```

3. Создать пользователей _user\_N_, где N =1, 2, .., 5, uid учетной записи должен быть равен 2000+N. 
4. Пользователей с N равным 1 и 2 добавить в группу workers вручную внеся изменения в конфигурационный файл. 
5. Пользователей с N равным 3, 4 и 5 добавить в группу _students_ при помощи команд администрирования. 
6. Создать пользователя _student_. В комментарии к учетной записи должны быть Ваше имя и фамилия. uid учетной записи должен быть равен 3000. Пользователя добавить в группу _students_. 
7. Для всех пользователей задайте пароли, используя команду _passwd_. 
8. Создать директорию _labs_ в корневом каталоге. В нем создать каталоги _library_ и _tests_ 
9. Создать файлы book\_[фамилия студента]\_N и поместить их в _library_ 
10. Создать текстовый файл test\_[имя студента], и поместить в _tests_. Файлы должны содержать скрипт на создание пользователя _user[номер варианта]_ и задание ему пароля _pass[номер варианта]_. Сделайте эти файлы исполняемыми для пользователей группы students. 
11. В директории _labs_ создать файл _list_, который должен содержать список файлов директории /etc. 
12. Дать право на изменение файла только пользователю _teacher_, а на чтение пользователям группы workers. 
13. Настроить права доступа к каталогу _library_ и _tests_, таким образом, чтобы пользователи группы _teachers_ могли изменять и создавать там файлы, а пользователи группы _students_ имели доступ на чтение


#### Методические указания

Linux,  как  и  любая  unix-подобная  система,  является  не  только  многозадачной,  но  и многопользовательской,  т.е.  эта операционная  система позволяет  одновременно нескольким пользователям работать с ней. Но система должна как-то узнавать, какой или какие  из  пользователей  работают  в  данный  момент.  Именно  для  этих  целей  в  Linux существует два понятия – учетные записи и аутентификация, которые являются частями одного механизма. 

Учетная  запись  пользователя –  это  необходимая  для  системы информация о пользователе,  хранящаяся  в  специальных  файлах.  Информация используется  Linux  для аутентификации пользователя и назначения ему прав доступа. 

Аутентификация –  системная  процедура,  позволяющая  Linux  определить,  какой именно пользователь осуществляет вход. 

Вся информация о пользователе обычно хранится в файлах _/etc/passwd_ и _/etc/group_. 

_/etc/passwd_ –  этот файл содержит  информацию  о  пользователях. Запись для  каждого пользователя занимает одну строку: 

- имя пользователя – имя, используемое пользователем на все приглашения типа login при аутентификации в системе. 
- зашифрованный пароль – обычно хешированный по необратимому алгоритму MD5 пароль пользователя или символ '!', в случаях, когда интерактивный вход пользователя в систему запрещен. 
- UID – числовой идентификатор пользователя. Система использует его для распределения прав файлам и процессам. 
- GID – числовой идентификатор группы. Имена групп расположены в файле /etc/group. Система использует его для распределения прав файлам и процессам. 
- Настоящее имя пользователя – используется в административных целях, а также командами типа finger (получение информации о пользователе через сеть). 
- Домашний каталог – полный путь к домашнему каталогу пользователя. 
- Оболочка – командная оболочка, которую использует пользователь при сеансе. Для нормальной работы она должна быть указана в файле регистрации оболочек /etc/shells. 

_/etc/group_ – этот файл содержит информацию о группах, к которым принадлежат пользователи:

- Имя группы – имя, применяемое для удобства использования таких программ, как _newgrp_ . 
- Шифрованный пароль – используется при смене группы командой _newgrp_. Пароль для групп может отсутствовать. 
- GID – числовой идентификатор группы. Система использует его для распределения прав файлам и процессам. 
- Пользователи, включенные в несколько групп – В этом поле через запятую отображаются те пользователи, у которых по умолчанию (в файле _/etc/passwd_ ) назначена другая группа. 

На сегодняшний день хранение паролей в файлах _passwd_ и _group_ считается ненадежным. 

В новых версиях Linux применяются так называемые теневые файлы паролей – _shadow_ и _gshаdow_. Права на них назначены таким образом, что даже чтение этих файлов без прав суперпользователя невозможно. Нужно учесть, что нормальное функционирование системы при использовании теневых файлов подразумевает одновременно и наличие файлов _passwd_ и _group_. При использовании теневых паролей в _/etc/passwd_ и _/etc/group_ вместо самого пароля устанавливается символ 'x', что и является указанием на хранение пароля в _/etc/shadow_ или _/etc/gshadow_. 

Файл shadow хранит защищенную информацию о пользователях, а также обеспечивает механизмы устаревания паролей и учетных записей. Вот структура файла shadow : 

- имя пользователя ;  
- шифрованный пароль – применяются алгоритмы хеширования, как правило MD5 или символ '!', в случаях, когда интерактивный вход пользователя в систему запрещен;  
- число дней с последнего изменения пароля, начиная с 1 января 1970 года;  
- число дней, перед тем как пароль может быть изменен;  
- число дней, после которых пароль должен быть изменен;  
- число дней, за сколько пользователя начнут предупреждать, что пароль устаревает;  
- число дней, после устаревания пар 

В Linux, кроме обычных пользователей, существует один (и только один) пользователь с неограниченными правами. Идентификаторы UID и GID такого пользователя всегда 0 . Его имя, как правило, _root_, однако оно может быть изменено (или создано несколько символьных имен с одинаковым GID и UID), так как значение для применения неограниченных прав доступа имеет только GID 0 . Для пользователя root права доступа к файлам и процессам не проверяются системой. При работе с использованием учетной записи root необходимо быть предельно осторожным, т.к. всегда существует возможность уничтожить систему. 

В Linux используется развитая система распределения прав пользователям. Но для точного опознания пользователя одного имени недостаточно с точки зрения безопасности. Именно поэтому используется и пароль – произвольный набор символов произвольной длины, обычно ограниченной лишь используемыми методами шифрования. 

Сегодня в большинстве версий Linux пароли шифруются по алгоритмам 3DES и MD5 (устарело, теперь SHA512). Когда алгоритм 3DES является обратимым, то есть такой пароль можно расшифровать, MD5 – это необратимое преобразование. Пароли, зашифрованные по алгоритму 3DES не применяются при использовании теневых файлов для хранения паролей. 

При аутентификации, пароль, введенный пользователем, шифруется тем же методом, что и исходный, а потом сравниваются уже зашифрованные копии. Если они одинаковые, то аутентификация считается успешной. 

Учитывая ежедневно увеличивающиеся требования к безопасности, в Linux есть возможность использовать скрытые пароли. Файлы _/etc/passwd_ и _/etc/group_ доступны для чтения всем пользователям, что является довольно большой брешью в безопасности системы. Именно поэтому в современных версиях Linux предпочтительнее использовать скрытые пароли. Такие пароли располагаются в файлах _/etc/shadow_ и _/etc/gshadow_, для паролей пользователей и групп соответственно.

Команда _login_ запускает сеанс интерактивной работы в системе. Она проверяет правильность ввода имени и пароля пользователя, меняет каталог на домашний, выстраивает окружение и запускает командный интерпретатор. Команду _login_ как правило не запускают из командной строки — это обычно за пользователя делают менеджеры консоли — например _getty_ или _mgetty_. 

Команда _su_ (switch user) позволяет сменить идентификатор пользователя уже в процессе сеанса. Синтаксис ее прост: _su_ username, где username – имя пользователя, которое будет использоваться. После этого программа запросит пароль. При правильно введенном пароле, _su_ запустит новый командный интерпретатор с правами пользователя, указанного _su_ и присвоит сеансу его идентификаторы. Если имя пользователя опущено, то команда _su_ использует имя root. 

```bash
su root 
	Password: 
#_ 
```

При использовании команды _su_ пользователем _root_ она, как правило, не запрашивает пароль. 

Команда _newgrp_ аналогична по своим возможностям _su_ с той разницей, что происходит смена группы. Пользователь должен быть включен в группу, которая указывается в командной строке _newgrp_ . При использовании команды _newgrp_ пользователем root она никогда не запрашивает пароль. Синтаксис команды аналогичен синтаксису команды _su_: _newgrp_ _groupname_, где _groupname_ – имя группы, на которую пользователь меняет текущую. 

Команда _passwd_ является инструментом для смены пароля в Linux. Для смены своего пароля достаточно набрать в командной строке _passwd_: 

```bash
passwd 
	Changing password for student 
	(current) UNIX password: 
	New password: 
	Retype new password: 
	passwd: all authentication tokens updated successfully 
$_ 
```

Для смены пароля группы и управления группой используется команда _gpasswd_ Для смены пароля достаточно набрать в командной строке _gpasswd_ _GROUPNAME_ . Сменить пароль вам удастся только если Вы являетесь администратором группы. Если пароль не пустой,то для членов группы вызов _newgrp_ пароля не требует, а не члены группы должны ввести пароль. Администратор группы может добавлять и удалять пользователей с помощью параметров -a и -d соответственно. Администраторы могут использовать параметр -r для удаления пароля группы. Если пароль не задан, то только члены группы с помощью команды _newgrp_ могут войти в группу. Указав параметр - R можно запретить доступ в группу по паролю с помощью команды _newgrp_ (однако на членов группы это не распространяется). Системный администратор ( _root_ ) может использовать параметр -A, чтобы назначить группе администратора. 

Команда _change_ управляет информацией об устаревании пароля и учетной записи. Обычный пользователь (не _root_ ) может использовать команду только для просмотра своих параметров устаревания пароля: 

```bash
change -l gserg 
	Last password change : Май 03, 2007 
	Password expires : never 
	Password inactive : never 
	Account expires : never 
	Minimum number of days between password change : 0 
	Maximum number of days between password change : 99999 
	Number of days of warning before password expires : 7 
```

Суперпользователь же может использовать также иные параметры, такие как: 

- -d дата (в формате системной даты, например ДД.ММ.ГГГГ) – устанавливает дату последней смены пароля пользователем. 
- -E дата – установить дату устаревания учетной записи пользователя 
- -I N – установить количество дней неактивности N с момента устаревания пароля перед тем как учетная запись будет заблокирована 
- -m N – задает минимальное количество дней (N) между сменами пароля 
- -M N – задает максимальное количество дней (N) между сменами пароля 
- -W N – задает количество дней, за которые будет выдаваться предупреждение об устаревании пароля.

#### Задания для самостоятельного выполнения

1. Определить значение _umask_, при котором создаваемые файлы будут доступны для исполнения всем.
2. Создать в домашнем каталоге подкаталог _tmp_, в котором сможет создавать, удалять и переименовывать файлы любой пользователь, входящий в группу student, но при этом его содержимое не должно быть видимым никому кроме владельца. Проверить правильность настроек доступа. 
3. Создать в домашнем каталоге папку shared, в которой могут создавать файлы любые пользователи, но удалять файлы могут только те, кто их создал. Проверить правильность настроек доступа. 

#### Контрольные вопросы

1. Какие основные файлы хранят информацию о зарегистрированных в системе пользователях?
2. Как добавить пользователя в систему?
3. Зачем операционная система отслеживает дату назначения пароля пользователю?
4. Для чего служит пароль группы?
5. Каково назначения файла _/etc/shadow_?
6. Как поменять пароль пользователю? Кто может это сделать?
7. Почему возникает необходимость выполнить команду от имени другого пользователя?


- # Практическая работа - управление правами доступа

#### Основное задание


1. Войти в систему с собственной учетной записью
2. Создать в домашнем каталоге 2-3 файла произвольного содержания (имена файлов - _u1, u2, u3_).
3. Получить развернутый список файлов домашнего каталога и сохранить его в файле _listing1_
4. Просмотреть файл _listing1_, обратив внимание на поля прав доступа, владельца и группы
5. Повторить п. 2 от имени пользователя root в новом сеансе или по команде _su_ (имена файлов - _r1, r2, r3_). Завершить сеанс _root_
6. Повторить п.3, результат дописать в файл _listing1_
7. Открыть файл _listing1_ и сравнить права доступа для файлов, созданных от вашего имени и от имени суперпользователя
8. Изменить содержимое файлов, созданных вами и суперпользователем. Сохранить изменения
9. Открыть сеанс _root_
10. Перейти в каталог _/home/ваша_учетная_запись_
11. Изменить права доступа к файлам _u1_ и _r1_ следующим образом:
    * _u1_: запретить запись для владельца и группы
    * _r1_: разрешить запись для всех
12. Переключиться в сеанс пользователя и изменить содержимое файлов _u1_ и _r1_. Сохранить изменения
13. Перейти в сеанс root и изменить владельца файлов _u1_ и _u2_ на _root_, а группу - на _stud_ 
14. Из _tty1_ попробовать изменить файл u2
15. Из _tty2_ создать каталоги _/home/shared, home/shared/pub, /home/shared/upload, /home/shared/temp_. Установить на них следующие права:

<table>
  <tr>
   <td>
каталог
   </td>
   <td>владелец
   </td>
   <td>группа
   </td>
   <td>права
   </td>
  </tr>
  <tr>
   <td>pub
   </td>
   <td>root
   </td>
   <td>users
   </td>
   <td>775
   </td>
  </tr>
  <tr>
   <td>upload
   </td>
   <td>nobody
   </td>
   <td>users
   </td>
   <td>130
   </td>
  </tr>
  <tr>
   <td>temp
   </td>
   <td>stud
   </td>
   <td>users
   </td>
   <td>777
   </td>
  </tr>
</table>


16. Выполнить копирование, чтение, удаление файлов _u1, u2, u3, r1, r2, r3_ в каталоги, созданные в п. 15 из сеансов _root_, _stud_ и вашего. Сравнить и проанализировать результаты.


#### Методические указания

Выполняя предыдущие лабораторные работы вы уже сталкивались с разграничением прав доступа в ОС Линукс. Такое разграничение обусловлено многозадачностью и многопользовательским режимом Линукс и призвано повысить безопасность и надежность системы, а также обеспечить защиту конфиденциальной информации.

Каждый файл в Линукс характеризуется набором атрибутов, определяющих его принадлежность и права доступа. Отношение принадлежности файла определено для:

* владельца файла(_user_) - пользователя, создавшего (что не обязательно) этот файл;
* группы (_group_) - в состав которой входит владелец;
* прочих (_other_) пользователей.

Для каждого объекта в файловой системе Linux существует набор прав доступа, определяющий взаимодействие пользователя с этим объектом. Такими объектами могут быть файлы, каталоги, а также специальные файлы (например, устройства) — то есть по сути любой объект файловой системы. Так как у каждого объекта в Linux имеется владелец, то права доступа применяются относительно владельца файла. Они состоят из набора 3 групп по три атрибута:  


* чтение( r ), запись( w ), выполнение( x ) для владельца;  
* чтение, запись, выполнение для группы владельца;  
* чтение, запись, выполнение для всех остальных. 

Атрибуты файла могут быть представлены в символьном или числовом виде. Символьное представление атрибутов - это строка, где последовательно записаны права доступа в следующем виде:

```
rwxrwxrwx
```

где каждая тройка символов определяет права на чтение (r), запись (w) и исполнение (x) для соответствующих пользователей (первая тройка - для владельца (user), вторая - для группы (group), третья - для прочих (other).

К правам доступа относятся: чтение (read), изменение (write), исполнение (execute). Понимание этих прав будет различным и зависеть от содержания файла. Наибольшие различия - между обычными (regular) файлами и каталогами. Эти различия приведены в табл. 1.


<table>
  <tr>
   <td> 
   </td>
   <td>Файлы
   </td>
   <td>Каталоги
   </td>
  </tr>
  <tr>
   <td>Чтение
   </td>
   <td>Просмотр содержимого файла (например, текста) в соответствующей программе и возможность его копирования
   </td>
   <td>Обзор списка файлов и возможность копирования каталога (в общем случае, вместе со всем содержимым)
   </td>
  </tr>
  <tr>
   <td>Изменение
   </td>
   <td>Редактирование содержимого файла и его копирование, но не удаление или переименование/перемещение
   </td>
   <td>Обеспечивает возможность записи и удаления файлов
   </td>
  </tr>
  <tr>
   <td>Исполнение
   </td>
   <td>Разрешает запуск программ и сценариев оболочки
   </td>
   <td>Разрешает переход в каталог и перемещение по нему
   </td>
  </tr>
</table>


Таким образом появляется возможность создания так называемых "скрытых" каталогов, когда невозможно получить список файлов, но пользователь точно знающий имя файла может скопировать его из "скрытого" каталога. 

Вот пример отображения списка файлов с правами доступа, представленными в символьном виде:

```bash
dir -L1 
	итого 2722316 
	-rw-r--r-- 1 aag users 498444757 Ноя 27 16:15 aag.asoiu.tar.gz 
	drwxr-xr-x 2 aag users 4096 Июн 1 2007 bin 
	-rw-r--r-- 1 aag users 26 Фев 20 10:20 description.txt 
	drwxr-xr-x 5 aag users 4096 Мар 2 20:01 Desktop 
	drwx------ 2 aag users 4096 Фев 23 09:50 Documents 
	drwxr-xr-x 4 aag users 4096 Фев 28 00:03 downloads 
	-rwxrwxr-x 1 aag users 7523 Окт 20 2006 Dz19.jpg 
	-rw-r--r-- 1 aag users 8336 Фев 24 01:12 httpd.myconf 
	-rw-r--r-- 1 aag users 20 Фев 25 16:32 index.html 
	-rw-r--r-- 1 aag users 30296 Фев 23 10:05 logofish.xcf 
	drwxr-xr-x 2 aag users 4096 Сен 28 22:53 Music 
	drwxr-xr-x 3 aag users 4096 Дек 3 13:45 Projects 
	drwxr-xr-x 4 aag users 4096 Фев 26 00:05 public_html 
	-rw-r--r-- 1 aag users 1088 Фев 20 10:18 readme.txt 
	drwxr-xr-x 4 aag users 4096 Фев 27 23:41 scrapbook 
	-rw------- 1 root root 0 Июн 2 2007 session_mm_cli0.sem
```

Обратите внимание на первые символы в записи прав доступа. В приведенном листинге первый символ d указывает, что файл является каталогом. Признаком специального символьного и блочного устройств являются символы с и b, а для каналов (pipes) соответственно p.

Числовое представление прав доступа - это трехзначное число, каждая цифра которого определяет (слева направо) права для владельца, группы и прочих. Права определяются как сумма цифр 4 (чтение), 2 (запись) и 1 (исполнение). Таким образом, например файл f1, создателем которого является user1 и разрешенный для чтения и изменения членам группы users и только для чтения всем прочим, будет иметь следующие атрибуты:

- в символьном виде: rw-rw-r--

- в числовом виде: 664

Вновь создаваемый файл обычно получает права rw-r--r-- (зависит от установок системы и значения _umask_ (см. _man umask_). Для изменения атрибутов используется команда chmod, которая может принимать как символьное, так и числовое представление атрибутов в качестве параметра. Ниже приведены примеры использования команды:

```bash
dir hello.txt 
	**-rw-r--r--** 1 aag users 17 Мар 2 22:32 hello.txt 
chmod **go+w** hello.txt // _разрешить запись для группы и прочих_ 
dir hello.txt 
	**-rw-rw-rw-** 1 aag users 17 Мар 2 22:32 hello.txt  
chmod **ug+x** hello.txt // _разрешить выполнение для владельца и группы_ 
dir hello.txt 
	**-rwxrwxrw-** 1 aag users 17 Мар 2 22:32 hello.txt 
chmod **a-x** hello.txt // _запретить выполнение для всех (**a** == ugo)_ 
dir hello.txt 
	**-rw-rw-rw-** 1 aag users 17 Мар 2 22:32 hello.txt 
chmod **go-w** hello.txt // _запретить запись для группы и прочих_ 
dir hello.txt 
	**-rw-r--r--** 1 aag users 17 Мар 2 22:32 hello.txt 
chmod **755** hello.txt // _разрешить чтение и выполнение всем и запись владельцу_ 
dir hello.txt 
	**-rwxr-xr-x** 1 aag users 17 Мар 2 22:32 hello.txt 
chmod **644** hello.txt // _запретить выполнение всем_ 
dir hello.txt 
	**-rw-r--r--** 1 aag users 17 Мар 2 22:32 hello.txt 
chmod **711** hello.txt // _разрешить только выполнение для группы и прочих_ 
dir hello.txt 
	**-rwx--x--x** 1 aag users 17 Мар 2 22:32 hello.txt
```

Для распределения прав доступа в Linux существует множество команд. Основные из них – это _chmod_, _chown_ и _chgrp_. Для смены владельца файла и группы (опционально) используется команда _chown_, а для смены группы - команда _chgrp_ (см. _man chown, man chgrp_).

В символьном виде использование команды chmod будет выглядеть следующим образом: 


```
chmod [ugoa] [+-] [rwx] filename
```


где: u,g,o,a – установка прав для пользователя, группы, остальных пользователей, всех групп прав доступа соответственно. 

+,-,= – добавить, удалить, установить разрешение соответственно. 

r,w,x,X,u,g,o – право чтения, записи, выполнения, выполнения если есть такое право еще у какой либо из групп доступа, такие же как у владельца, такие же как у группы, такие же как у остальных пользователей. 

filename - Имя файла, у которого изменяются права. 

Просмотр разрешений, установленных на файл осуществляется командой ls с ключом -l: 

```bash
ls -l lesson5.txt
	-rw------- 1 student student 39 Nov 19 15:17 lesson5.txt 
chmod g+rw lesson5.txt 
ls -l lesson5.txt 
	-rw-rw---- 1 student student 39 Nov 19 15:18 lesson5.txt 
chmod o=u lesson5.txt 
ls -l lesson5.txt 
	-rw-rw-rw- 1 student student 39 Nov 19 15:18 lesson5.txt 
chmod o-w lesson5.txt 
ls -l lesson5.txt 
	-rw-rw-r-- 1 student student 39 Nov 19 15:19 lesson5.txt 
```

Для использования абсолютного режима необходимо представить права доступа к файлу в виде 3-х двоичных групп. Так например: 

rwx r-x r-- будет выглядеть как: 111 101 100 

Теперь каждую двоичную группу перевести в 8-ричное число: 111 – 7, 101 – 5, 100 – 4 . 

Чтобы задать файлу такие права необходимо выполнить команду: 

```bash
ls -l lesson5.txt 
	-rw-rw-r-- 1 student student 39 Nov 19 15:19 lesson5.txt 
chmod 754 lesson5.txt 
ls -l lesson5.txt 
	-rwxr-xr-- 1 student student 39 Nov 19 15:19 lesson5.txt 
```

Также предложить им проделать то же самое в символьном виде. 

Команда _chown_ (CHange OWNer – сменить владельца) – позволяет сменить владельца файла. Для использования этой команды необходимо либо иметь права владельца текущего файла или права root . Синтаксис команды прост: 

```bash
chown username:groupname filename 
```

где _username_ – имя пользователя – нового владельца файла; _groupname_ – имя группы – нового владельца файла; _filename_ – имя файла, у которого сменяется владелец. 

Имя группы в синтаксисе команды можно не указывать, тогда будет изменен только владелец файла. 

Команда _chgrp_ используется для изменения владельца-группы файла. Синтаксис ее таков: 

```bash
chgrp groupname filename
```

где: _groupname_ – имя группы, которой будет принадлежать файл _filename_ – имя изменяемого файла 

Имейте в виду, что использовать команды _chown_ и _chmod_ может только пользователь-владелец файла и _root_ , а команду _chgrp_ - пользователь-владелец файла, группа-владелец файла и _root_ . 

Существуют еще несколько особых прав, которые могут устанавливаться на файлы и каталоги. О некоторых из них мы поговорим при изучении темы "процессы". Но один рассмотрим сейчас. Это так называемый _sticky bit_ (бит прикрепления). 

В первых версиях Юникс этот бит использовался для того, чтобы заставить систему при работе программы оставлять образ ее кода в памяти. Тогда при следующем обращении к программе на ее запуск тратилось намного меньше времени так как чтение кода с устройства более не требовалось. Для файлов и сегодня в Linux осталось прежнее значение этого бита. А вот для каталогов этот атрибут приобрел новое значение. Если _sticky bit_ установлен на каталог, то удалить файлы из такого каталога может только пользователь-владелец файла, и то только если у него есть право на запись в файл. Группа-владелец и остальные пользователи даже при наличии прав на запись в файл не смогут удалить его при установленном на каталог _sticky bit_. Бит прикрепления устанавливается командой _chmod_ в символьном виде: 

```bash
chmod +t filename 
```


#### Задания для самостоятельного выполнения

1. В текущей папке создать файл hello следующего содержания

```bash
#!/bin/sh \
echo Hello, World! \
echo -n "I'm " \
whoami
```

2. Выполнить следующие действия и проанализировать результаты:
    * набрать в командной строке имя файла _hello_ и нажать Enter
    * набрать в командной строке _sh hello_ и нажать Enter
    * установить для файла _hello_ права на исполнение (x), ввести имя файла в командной строке (_./hello_) и нажать _Enter_
3. Разберитесь, как в Linux можно организовать специальные каталоги-файлообменники - такие, что создавать в них файлы могут любые пользователи, а удалять - только владельцы файлов (тот, кто их создал).

#### Контрольные вопросы

1. Зачем у файла нужны атрибуты доступа?
2. Для каких трех категории пользователей задаются права доступа каждого конкретного файла?
3. Для чего в UNIX-подобных системах используются пользовательские группы?
4. Какие действия с файлами регламентируются правами доступа?
5. На какой системе счисления основывается числовое представление прав доступа?
6. Чем отличается назначение прав доступа к простому файлу и к директории?
7. Кто может менять права доступа определенного файла?
8. Каково назначение специальных битов прав доступа?
