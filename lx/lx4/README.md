
Практика студентов Финансового университета
=========

# Сетевые системы и приложения


- # Процессы и пакеты в Linux

- - # Практика: Управление пакетами

#### Основное задание



1. Откройте окно менеджера программ и познакомьтесь с набором программного обеспечения, входящего в стандартный репозиторий вашей операционной системы.
2. Найдите и установите программу _chromium-browser._ Проверьте ее работоспособность.
3. Удалите установленную программу _firefox_.
4. Произведите обратные действия (установку _firefox_ и удаление _chromium_) командами в терминале.
5. Откройте менеджер пакетов _Synaptic_ в графическом режиме. 
6. Выведите полный список пакетов, установленных в системе. Подсчитайте общее количество пакетов, установленных в системе.
7. Выберите из общего списка все пакеты, имеющие в названии слово gnome (т.е. те пакеты, которые принадлежат интегрированной среде _GNOME_) и подсчитайте их количество.
8. Проверьте, установлен ли в системе пакет _mc_ и получите расширенную информацию об этом пакете.
9. Выполните имитацию удаления (НЕ УДАЛЕНИЕ!) пакета _perl_. Подсчитайте количество пакетов, которые от него зависят.
10. Выполните имитацию установки пакетов _httpd, vsftpd и webmin_, проанализировать результаты (убедиться, что все зависимости удовлетворены).
11. Повторите задания 6-10 в консольном режиме с использованием программы _dpkg_.
12. Установите программу _PyCharm_, следуя инструкциям на сайте производителя. Добавьте ярлык программы на рабочий стол или панель и убедитесь, что программа работает правильно. 


#### Методические указания 

Одна из первых вещей, на которые вы обращаете внимание при установке Linux -- это большое количество входящих в дистрибутив пакетов. Большинство дистрибутивов содержат операционную систему Linux, средства для инсталляции и средства администрирования. Кроме того, в них включаются средства для работы в Интернете, средства разработки, офисные пакеты, игры, а также некоторые средства, о которых вы даже не слышали. Дистрибутивы Linux, содержащие тысячи доступных пакетов, не редкость. Если вы не выбрали "установить все", будет установлено некоторое подмножество этих пакетов. 

Теперь у вас могут возникнуть вопросы "Как удалить ненужные пакеты? Как установить что-то недостающее? Могу ли я использовать программное обеспечение, не входящее в мой дистрибутив?" 


##### Зависимости

Разные разработчики разрабатывают разные программы и библиотеки. Определенная программа может зависеть от десятка библиотек, которые разработали разные люди. Следить за всем этим вручную — неблагодарное занятие.

К счастью для нас, проблема эта решена. Каждый раз когда вы ставите какое-либо ПО из репозитория или вручную при помощи пакета-установщика, программа-установщик разбирает эти зависимости и устанавливает их вместе с нужным вам приложением. Но иногда бывает и такая ситуация, когда репозитории не подключены (например, если нет интернета) и единственный способ поставить программу — скачать ее предварительно где-нибудь и потом ставить вручную. В любом случае при установке вы будете предупреждены, если нужная зависимость не установлена и не может быть найдена в репозиториях, так что теперь вы знаете в чем дело.

И напоследок о зависимостях: допустим, вам надо скачать какую-то программу. Она тянет за собой 5 зависимостей. Каждый из них тянет за собой по 5 зависимостей еще. В итоге может получиться так, что сама программа занимает 1 мегабайт, а скачать надо 50.


##### .deb = setup.exe

В Windows, чтобы установить программу, необходимо скачать некий файл, наподобие setup.exe, который сам все установит. В дистрибутивах, основанных на Debian используется похожая система, только вместо setup.exe используются файлы с расширением .deb

Это пакет-установщик. В разных линукс-системах установщики могут быть разные. Например, в системе RedHat Linux для установки используются пакеты с расширением .rpm

Зачем это нужно знать? Когда вы ищите ПО в интернете (если его нету в репозиториях) — обычно на странице загрузки предоставляются различные пакеты. Вам нужен deb! Даже когда вы устанавливаете что-либо из репозитория, невидимо от вас программа скачивает deb файл (или несколько файлов, если имеются зависимости) и потом устанавливает его.


##### Программа apt.

Все архивы программного обеспечения, компакт-диски и т. д. не принесут никакой пользы, если вы не умеете устанавливать программы. Итак, вы хотите знать, как установить новый пакет в Debian. 

Воспользуйтесь командой apt install: 

```bash
sudo apt install tuxkart 
```

Установка пакета с перезаписью файлов: 

```bash
sudo apt install --reinstall tuxkart 
```
Чтобы установить сразу несколько программ, перечислите их, разделяя пробелами: 

```bash
sudo apt install tuxkart gltron frozen-bubble tuxracer nethack galaga 
```

Загрузка программ без установки или распаковки: 

```bash
sudo apt -d install tuxkart 
```

Чтобы протестировать команду перед выполнением, присоедините к строке ключ - dry-run: 

```bash
sudo apt install tuxkart gltron frozen-bubble tuxracer nethack galaga --dry-run 
```

##### Удаление пакетов

Для удаления одного или нескольких пакетов воспользуйтесь командой apt remove: 

```bash
sudo apt remove tuxpaint 
```

Предварительное тестирование команды remove: 

```bash
sudo apt remove tuxpaint -dry-run 
```

Удаление всех следов существования пакета, включая конфигурационные файлы:

```bash
sudo # apt --purge remove tuxpaint 
```

Чтобы удалить сразу несколько программ, перечислите их, разделяя пробелами: 

```bash
sudo apt remove tuxkart gltron frozen-bubble tuxracer nethack galaga
```

##### Обновление пакетов

Часто требуется обновить пакет в системе Debian, потому что новая версия обладает расширенными возможностями или в ней исправлены ошибки. Воспользуйтесь командой apt install: 

```bash
sudo apt install gltron 
```

Обновление нескольких пакетов: 

```bash
sudo apt install tuxkart gltron frozen-bubble tuxracer nethack galaga 
```

Команды обновления отдельных пакетов не существует. Команда apt install всегда устанавливает последнюю версию пакета. 


##### Обновление системы

При обновлении системы полностью требуется обновить все пакеты в системе и заменить их новейшими версиями. Убедитесь в том, что файл /etc/apt/sourcs.list содержит ссылки на нужные источники, а затем выполните команду apt upgrade. 

Всегда начинайте с обновления списков пакетов: 

```bash
sudo apt update 
```

Следующая команда обновляет все установленные пакеты, но не удаляет пакеты для разрешения зависимостей: 

```bash
sudo apt -u upgrade 
```

Обновление всех установленных пакетов с удалением или установкой пакетов по мере необходимости для разрешения всех зависимостей: 
```bash
sudo apt -u dist-upgrade 
```

Флаг -u позволяет заранее просмотреть список всех изменений. Обновление может занять несколько часов, в зависимости от скорости подключения к Интернету и количества загружаемых пакетов. 

Чтобы флаг -u применялся по умолчанию, отредактируйте (или создайте) файл /etc/apt/apt.conf: 

```
// Всегда перечислять обновляемые пакеты 
// и запрашивать подтверждение у пользователя 
APT::Get::Show-Upgraded "true"; 
```
Перед каждым выполнением команды apt_get dist_upgrade сначала выполните команду apt upgrade, чтобы снизить вероятность ошибок при выполнении distupgrade


##### Поиск установленных программ

Следующая команда выводит список всех установленных пакетов и направляет его в файл: 

```bash
dpkg -l | tee dpkglist 
```

Поиск всех пакетов, удовлетворяющих критерию поиска, и вывод информации об их состоянии: 

```bash
dpkg -l '*gnome*' 
```

Поиск установленных пакетов, удовлетворяющих критерию поиска: 

```bash
dpkg -l | grep gnome 
```

Вывод списка файлов, входящих в пакет: 

```bash
dpkg -L gnome-applets
```

##### Операции с кэшем пакетов 

Время от времени требуется обеспечить актуальность кэша пакетов и списков пакетов, чтобы программа apt работала правильно, без возникновения ложных проблем с зависимостями. 

Воспользуйтесь программами apt и dpkg. Не забывайте выполнять команду apt update после модификации файла /etc/apt/sources.list, а также регулярно выполняйте ее, чтобы список пакетов оставался актуальным. 

Следующая команда выводит список загруженных, но не установленных пакетов: 

```bash
dpkg --yet-to-unpack 
```

Проверка нарушенных зависимостей: 

```bash
apt check 
```

Удаление кэшированных пакетов, которые стали ненужными: 

```bash
$ apt-cache autoclean 
```

Удаление всех кэшированных пакетов: 

```bash
apt-cache clean 
```

Вывод списка частично установленных пакетов: 

```bash
dpkg -audit 
```

Если вызов dpkg --audit возвращает какие-либо результаты, как в следующем случае: 

```bash
dpkg --audit
vpw (no information available) 
```

для начала убедитесь в том, что возвращаемый пакет существует: 

```bash
dpkg -l 
vpw Package 'vpw' is not installed and no info is available 
```

Если пакет существует, либо завершите установку, либо удалите ее. Если пакет не установлен, поищите соответствующую запись в /var/lib/dpkg/available и /var/lib/dpkg/status и удалите ее


##### Разрешение конфликтов зависимостей 

Иногда может произойти такая ситуация, что какая-либо программа не устанавливается из-за проблем с зависимостями, или команда apt dist-upgrade оставляет пакеты, которые нужно удалить. Существует несколько команд, которые могут пригодиться для решения этой задачи; в этом разделе они перечисляются в том порядке, в котором их стоит попробовать. 

Допустим, проблемы возникли с пакетом libpam-modules, который не желает обновляться: 

```bash
sudo  apt install libpam-modules 
	... 
	The following packages have unmet dependencies: 
	libpam-modules: Depends: libdb3 (>=3.2.9-19.1) but 3.2.9-19 is to be installed 
	E: Broken packages 
```

Если вы работаете в смешанной системе, для начала попробуйте указать версию: 

```bash
sudo  apt install -t stable libpam-modules 
```

Если это не помогает или система не является смешанной, попробуйте воспользоваться системой разрешения конфликтов Debian: 

```bash
sudo apt -f install 
```

Затем выполните команду: 
```bash
sudo  dpkg --configure -a 
```

И снова повторите команду: 

```bash
sudo apt -f install 
```

Если будет получен следующий ответ, значит, попытка завершилась неудачей: 

```
Reading Package Lists... Done 
Building Dependency Tree... Done 
0 upgraded, 0 newly installed, 0 to remove and 1 not upgraded. 
```

Теперь проверьте, что произойдет при удалении существующего пакета libpammodules: 

```bash
sudo apt remove --dry-run libpam-modules 
	Reading Package Lists... Done 
	Building Dependency Tree... Done 
	The following packages will be REMOVED: adduser adminmenu apache at base-config courier-imap courier-imap-ssl courier-pop courier-pop-ssl cron cupsys cupsys-driver-gimpprint dict-elements dict-foldoc dict-gcide dict-jargon dict-vera dict-wn dictd gdm2... 
	.... 
	WARNING: The following essential packages will be removed 
	This should NOT be done unless you know exactly what you are doing! 
	login libpam-modules (due to login) 
```

В данном случае исправление конфликтов зависимостей потребует едва ли не полной перестройки системы. Чаще проблемы ограничиваются несколькими пакетами. В этом случае начинайте удалять наименее важные из них, пока конфликты зависимостей не будут разрешены, а затем переустановите все пакеты, которые вам нужны. 

Если apt -u dist-upgrage отображает какие-либо задержанные (held) пакеты, от них лучше избавиться. Пакеты удерживаются из-за конфликтов зависимостей, которые не удается разрешить apt. Попробуйте воспользоваться следующей командой для поиска и исправления конфликтов:

```bash
sudo apt -o Debug::pkgProblemResolver=yes dist-upgrade 
```

Если исправить конфликты не удается, команда завершается с сообщением 

```
	0 upgraded, 0 newly installed, 0 to remove and 6 not upgraded. 
```

Удаляйте held-пакеты один за одним, каждый раз запуская dist-upgrade, пока не останется ни одного задержанного пакета. Затем установите заново все необходимые пакеты. Не забудьте использовать ключ --dry-run, чтобы заранее знать обо всех последствиях: # apt remove --dry-run libsdl-perl В «монолитных» системах подобные конфликты версий встречаются редко. Пользователи смешанных систем сталкиваются с ними чаще. Чтобы предотвратить их, будьте чрезвычайно осмотрительны при выборе устанавливаемых программ — при первой установке Debian потратьте немного времени и выберите каждый необходимый пакет.


#### Самостоятельное изучение



1. Установка пакетов из исходных кодов. Команды _compile, make, make install_
2. Установка и запуск программ Windows в системе Linux. Программа-эмулятор _Wine_
3. Контейнерные пакеты _snap_ и _flatpack_.


#### Задания для самостоятельного выполнения



1. Установите другой менеджер рабочего стола (например, KDE или XFCE). Проверьте его работоспособность, залогинившись в него.
2. Установите какую-либо программу по вашему выбору из исходных кодов. 
3. Установите на вашу Linux-машину библиотеку _tensorflow-gpu_. Проверьте правильность установки, запустив в командной строке интерактивную консоль Python командой python и затем введя команду

```py
import tensorflow
```

Вы не должны получить сообщение об ошибке импорта.

#### Контрольные вопросы

1. Чем отличаются команды _apt_ и _apt-get_?
1. В чем различие программ для управления пакетами _apt_ и _dpkg_?
1. Какие менеджеры пакетов применяются в других дистрибутивах? В чем их особенности?
1. Как устанавливать пакеты из исходных кодов?
1. Зачем нужны контейнерные менеджеры пакетов? В чем их преимущества и недостатки?

- # Управление процессами в Linux

#### Основное задание



1. Войти в систему с собственной учетной записью
2. Получить справку о команде ps
3. Командой ps вывести краткую информацию о выполняющихся процессах в текущем терминале и определить PID текущей оболочки
4. Получить подробную информацию о загруженных процессах и выяснить, какой из них использует максимальный объем памяти, а какой - максимально загружает процессор
5. Из таблицы, полученной в п.4 выяснить, какой PID имеет процесс _init_ и от чьего имени он запущен
6. Открыть новый сеанс с собственной учетной записью в и запустить в нем текстовый редактор nano
7. Вернуться в исходный сеанс и снова просмотреть список процессов. Определить PID программы nano, запущенной от вашего имени
8. Командой _kill_ снять все процессы nano
9. В _tty1_ выполнить команду _top_. Сравнить ее возможности с возможностями ps
10. Используя top или ps определить, какие процессы порождены (поле PPID) процессом _init_  (PID=1)
11. Запустить поиск всех файлов .html от каталога _/_. Приостановить этот процесс (_Ctrl+Z_). 
12. Запустить команду man bash и приостановить ее выполнение
13. Командой _jobs_ определить номера задач, запущенных в предыдущих пунктах.
14. Командой _fg_ продолжить выполнение _man bash_.
15. Принудительно (_kill_) завершить команду _find_.

#### Методические указания

##### Понятие процесса

Под процессами во всех unix-подобных системах подразумевается любая независимо выполняющаяся программа со всеми используемыми ресурсами. Процесс - одно из ключевых понятий, на которых базируется Линукс, как unix-подобная система, и оно тесно связано с такими понятиями, как учетные записи, права доступа и файловая система. Эта связь неразрывна и, вдобавок, рекурсивна:

* пользователь (реальный или виртуальный) запускает процессы, порождающие файлы;
* права доступа процесса соответствуют правам доступа запустившего его пользователя;
* порожденные процессом файлы получают права, соответствующие правам процесса;
* права пользователя определены параметрами его учетной записи.

Каждый процесс уникален. Для идентификации процесса используется числовое значение, т.н. идентификатор процесса (PID, Process Identificator). Для каждого процесса известен владелец(пользователь, запустивший процесс). Если процесс создан реальным пользователем, то он привязан к терминалу, из которого был запущен. Для виртуальных (системных) пользователей такой ассоциации не производится. Помимо собственного идентификатора, каждый процесс имеет еще и идентификатор родительского процесса (PPID, Parent PID). В каждый момент времени системе известно состояние процесса - степень его исполнения. Процесс может быть:

* выполняемым в текущий момент (R, Runned);
* находящимся в режиме ожидания (S, Suspended);
* прерванным (T, Terminated), например, при использовании клавиш Ctrl+Z;
* "зомби" (Z, Zombied) - завершившимся, но от которого родительский процесс еще не принял сигнала завершения. Спустя некоторое время "зомби" завершаются окончательно и освобождают ресурсы;
* зависшим, или в состоянии непрерывного ожидания (uninterruptible sleep). Такой процесс не реагирует на какие-либо сигналы и может быть снят только перезагрузкой системы.

Все запущенные процессы условно (в зависимости от выполняемой ими функции) можно разделить на три типа: Системные процессы являются частью ядра и всегда расположены в оперативной памяти. Они часто не имеют соответствующих им программ в виде исполняемых файлов и всегда запускаются особым образом при загрузке ядра системы. Процессы-демоны – это неинтерактивные процессы, которые выполняются в фоновом режиме. К прикладным относятся все остальные процессы, выполняющиеся в системе. Интерактивные процессы связаны с определѐнным терминалом и через него взаимодействуют с пользователем. Фоновые процессы выполняются независимо от пользователя и (псевдо)параллельно. Каждый процесс в операционной системе Linux может находиться в одном из четырѐх состояний: работоспособный, спящий (или ожидающий), остановленный и завершившийся. 

Еще одной характеристикой процессов является уровень приоритета (NI, NIce value, "степень дружественности"). Уровень приоритета влияет на количество системных ресурсов, выделяемых процессу.

Основными командами для получения сведений о выполняемых процессах являются ps и top. Фрагмент вывода сведений командой ps с параметрами a (расширенный вывод), u (с указанием UID), x (в т.ч для виртуальных пользователей):

```bash
ps aux 
	USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND 
	root 1 0.0 0.0 744 284 ? Ss 14:27 0:00 init [5]  
	root 2 0.0 0.0 0 0 ? S< 14:27 0:00 [kthreadd] 
	root 3 0.0 0.0 0 0 ? S< 14:27 0:00 [migration/0] 
	root 4 0.0 0.0 0 0 ? SN 14:27 0:00 [ksoftirqd/0] 
	root 5 0.0 0.0 0 0 ? S< 14:27 0:00 [events/0] 
	root 6 0.0 0.0 0 0 ? S< 14:27 0:00 [khelper]
	root 25 0.0 0.0 0 0 ? S< 14:27 0:00 [kblockd/0] 
	... 
	root 141 0.0 0.0 0 0 ? S< 14:27 0:00 [kswapd0] 
	root 142 0.0 0.0 0 0 ? S< 14:27 0:00 [aio/0] 
	root 367 0.0 0.0 0 0 ? S< 14:27 0:00 [kpsmoused] 
	root 377 0.0 0.0 0 0 ? S< 14:27 0:00 [kondemand/0] 
	... 
	root 991 0.0 0.0 0 0 ? D< 14:28 0:01 [kjournald] 
	root 1682 0.0 0.0 0 0 ? S< 14:28 0:01 [ipw2200/0] 
	root 1694 0.0 0.0 0 0 ? S< 14:28 0:00 [khpsbpkt] 
	 
	wwwrun 3323 0.0 2.4 104548 12804 ? S 14:28 0:00 /usr/sbin/httpd 
	wwwrun 3324 0.0 2.4 104540 12816 ? S 14:28 0:00 /usr/sbin/httpd 
	 
	...
```

Дополнительная информация о команде ps доступна при указании параметра -_-help_ или в справке _man_.


##### Управление процессами

Чтобы запустить программу достаточно ввести ее имя в командной строке и нажать _«Enter»_. Однако не все команды запускают единственный процесс. 

Интерактивные процессы, запущенные в терминале, занимают терминальную сессию, и оболочка не выводит пользователю строку приглашения до тех пор, пока программа не завершится. 

```bash
firefox csc.sibsutis.ru 
```

Работу некоторых запущенных в терминале программ можно прервать с помощью сочетания клавиш «_Ctrl + c_» в окне терминала. В этот момент программе посылается сигнал INT (Interrupt). 

Чтобы запустить программу в фоновом режиме необходимо завершить команду символом амперсанд «&». После этого в терминал выводится информация о запущенном процессе включая номер задания терминала, и приглашения пользователю на ввод новой команды. 

```bash
top & 
```

Используя команду jobs мы можем получить список заданий которые запущены через терминал. 

```bash
jobs 
```

Чтобы вернуть запущенный в фоне процесс на передний план используется команда fg с указанием номера задания из списка заданий. 

```bash
fg %2 
```

Если мы хотим перевести процесс в состояние остановленный, используется сочетание клавиш «_Ctrl + z_». В этот момент программе посылается сигнал TSTP (Terminal Stop). 

После этого мы можем либо переместить задание на передний план командой _fg_, либо продолжить его выполнение в фоновом режиме командой _bg_. 

```bash
bg %2
```

Пользователь может управлять только теми процессами, владельцем которых является. Суперпользователь может управлять всеми процессами.

Управление запущенными процессами сводится к приостановке выполнения, изменению приоритета и принудительному завершению.

Приостановить выполнение активного процесса можно сочетанием клавиш _Ctrl+Z_. Для продолжения его работы можно использовать команду fg. Если имеется несколько приостановленных процессов, то для команды _fg_ необходимо указать порядковый номер задания в текущей оболочке, (не путать с PID), работу которого нужно продолжить. Узнать номер задания можно командой _jobs_.

Изменение приоритета процесса - задача, возникающая (нечасто) при необходимости перераспределения ресурсов системы. Значения уровня приоритета (_nice value_) изменяется от -20 (наименьшая "дружественность", высший приоритет) до +20 (низший приоритет). Все пользовательские (и большинство системных) процессы запускаются с равным приоритетом (_nice value_ = 0). Это значение может быть изменено двояко:

* Во-первых, при запуске программы командой nice с указанием необходимого уровня приоритета и именем запускаемой программы. Например:

```bash
nice -5 find / *.html
```

* Во-вторых, для ранее запущенной задачи, командой renice с указанием уровня и PID задачи. Например, так:

```bash
renice --7 20117
```

Пользователь имеет право понижать приоритет собственных задач. Повышать уровень приоритета любой задачи может только суперпользователь.

Гораздо чаще, чем изменение приоритета, возникает необходимость принудительного завершения (снятия) процесса. Такая ситуация возникает, например тогда, когда процесс "зависает", т.е. перестает воспринимать нажатия клавиш и не отвечает на системные события. Для снятия "зависшей" программы предназначена команда kill, которая передает ей один из сигналов завершения. Список сигналов доступен по команде kill -l, а их подробное описание - по команде man 7 signal. Здесь же отметим, что без явного указания имени (или номера), процессу будет передан сигнал SIGTERM (номер 15), предписывающий по возможности корректно, с сохранением информации, завершить работу. Примеры использования команды:

Вызов со значением сигнала по умолчанию (SIGTERM):

```bash
find / *.html 
ps 
	PID TTY TIME CMD 
	2663 pts/1 00:00:00 bash 
	20712 pts/1 00:00:00 find 
	20762 pts/1 00:00:00 ps 
kill 20712
```

Явное указание номера сигнала:

```bash
kill -15 20712
```

Явное указание имени сигнала (номер 9, SIGKILL, требующий немедленного завершения работы программы):

```bash
kill -SIGKILL 20712
```

##### Команда top

Большей гибкостью и универсальностью по сравнению с командой ps обладает команда _top_. Она позволяет не только получить информацию о процессах, но и выполнять мониторинг через заданные интервалы времени. Также эта команда позволяет управлять процессами, объединяя возможности команд j_obs, nice, fg_ и _kill_. Все параметры и действия команды _top_ являются настраиваемыми. Для команды доступна как справка в формате man, так и интерактивная справка по нажатию клавиш H или ?.

#### Задания для самостоятельного выполнения

1. В заданиях 3,4,5 и 7 написать команды, которые выводят только нужную информацию (идентификатор процесса). Используйте команды работы с текстом. 
2. Установите программу _htop_ и познакомьтесь с ней. Используя ее в процессе повседневной работы ответьте на несколько вопросов:
    1. Какие программы потребляют больше всего оперативной памяти?
    2. Насколько часто центральный процессор бывает загружен полностью и при выполнении каких задач?
    3. Сколько памяти потребляет система в режиме простоя?
    4. Требуется ли системе апгрейд и каких компонентов в первую очередь?

#### Контрольные вопросы

1. В системе зарегистрированы и работают пользователи _user1_ и _user2_. Может ли _user1_ завершить работу процесса, запущенного пользователем _user2_?
2. Может ли _user1_ понизить приоритет процесса, запущенного _user2_?
3. Может ли _user1_ повысить приоритет собственного процесса?
